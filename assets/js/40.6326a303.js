(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{308:function(t,e,s){"use strict";s.r(e);var a=s(13),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("!!!")]),t._v(" "),s("p",[t._v("This document has "),s("strong",[t._v("moved")]),t._v(".")]),t._v(" "),s("p",[t._v("You'll now find information like this in the "),s("a",{attrs:{href:"https://github.com/ipld/ipld/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ipld/ipld"),s("OutboundLink")],1),t._v(" meta-repo,\nand published to the web at https://ipld.io/ .")]),t._v(" "),s("p",[t._v("All documentation, fixtures, specifications, and web content is now gathered into that repo.\nPlease update your links, and direct new contributions there.")]),t._v(" "),s("p",[t._v("!!!")]),t._v(" "),s("hr"),t._v(" "),s("h1",{attrs:{id:"filecoin-actor-state-data-structures"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#filecoin-actor-state-data-structures"}},[t._v("#")]),t._v(" Filecoin Actor State Data Structures")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#initactor"}},[t._v("InitActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2"}},[t._v("v2")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#cronactor"}},[t._v("CronActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0-1"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2-1"}},[t._v("v2")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#rewardactor"}},[t._v("RewardActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0-2"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2-2"}},[t._v("v2")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#accountactor"}},[t._v("AccountActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0-3"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2-3"}},[t._v("v2")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#storagemarketactor"}},[t._v("StorageMarketActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0-4"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2-4"}},[t._v("v2")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#storagemineractor"}},[t._v("StorageMinerActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0-5"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2-5"}},[t._v("v2")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#multisigactor"}},[t._v("MultisigActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0-6"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2-6"}},[t._v("v2")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#paymentchannelactor"}},[t._v("PaymentChannelActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0-7"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2-7"}},[t._v("v2")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#storagepoweractor"}},[t._v("StoragePowerActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0-8"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2-8"}},[t._v("v2")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#verifiedregistryactor"}},[t._v("VerifiedRegistryActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0-9"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2-9"}},[t._v("v2")])])])]),t._v(" "),s("li",[s("a",{attrs:{href:"#systemactor"}},[t._v("SystemActor")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#v0-10"}},[t._v("v0")])]),t._v(" "),s("li",[s("a",{attrs:{href:"#v2-10"}},[t._v("v2")])])])])]),t._v(" "),s("p",[t._v("The Actor State tree attaches to the main chain via the "),s("code",[t._v("ParentStateRoot")]),t._v(" field of "),s("code",[t._v("BlockHeader")]),t._v(". This field either points directly to the "),s("code",[t._v("ActorsHAMT")]),t._v(" in v0 or via the intermediate "),s("code",[t._v("StateRoot")]),t._v(" from v2.")]),t._v(" "),s("p",[t._v("See "),s("RouterLink",{attrs:{to:"/data-structures/filecoin/chain.html#actor-type-linking"}},[t._v("Actor type linking")]),t._v(" for how each of the Actor State blocks below are attached to and differentiated within the "),s("code",[t._v("ActorsHAMT")]),t._v(".")],1),t._v(" "),s("h2",{attrs:{id:"initactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#initactor"}},[t._v("#")]),t._v(" InitActor")]),t._v(" "),s("p",[t._v("The InitActor state is the same in v0 and v2.")]),t._v(" "),s("h3",{attrs:{id:"v0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"initv0state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InitV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  AddressMap "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("ActorIDHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT[Address]ActorID")]),t._v("\n  NextID ActorID\n  NetworkName String\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h3",{attrs:{id:"v2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("em",[t._v("(Same as v0)")])]),t._v(" "),s("p",[s("a",{attrs:{name:"initv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InitV2State")])]),t._v(" InitV0State\n")])])]),s("p",[s("strong",[t._v("HAMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type ActorIDHAMT {Address:ActorID}")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ActorIDHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" ActorIDHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ActorIDHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ActorIDHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ActorIDHAMTBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ActorIDHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("ActorIDHAMT\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ActorIDHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" ActorIDHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ActorIDHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key Address\n  value ActorID\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h2",{attrs:{id:"cronactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cronactor"}},[t._v("#")]),t._v(" CronActor")]),t._v(" "),s("p",[t._v("The CronActor state is the same in v0 and v2.")]),t._v(" "),s("h3",{attrs:{id:"v0-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0-2"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"cronv0state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CronV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Entries "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("CronV0Entry"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CronV0Entry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The actor to call (must be an ID-address)")]),t._v("\n  Receiver Address\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The method number to call (must accept empty parameters)")]),t._v("\n  MethodNum MethodNum\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h3",{attrs:{id:"v2-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2-2"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("em",[t._v("(Same as v0)")])]),t._v(" "),s("p",[s("a",{attrs:{name:"cronv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CronV2State")])]),t._v(" CronV0State\n")])])]),s("h2",{attrs:{id:"rewardactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rewardactor"}},[t._v("#")]),t._v(" RewardActor")]),t._v(" "),s("p",[t._v("The RewardActor state differs between v0 and v2.")]),t._v(" "),s("h3",{attrs:{id:"v0-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0-3"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"rewardv0state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RewardV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CumsumBaseline is a target CumsumRealized needs to reach for EffectiveNetworkTime to increase")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CumsumBaseline and CumsumRealized are expressed in byte-epochs.")]),t._v("\n  CumsumBaseline Spacetime\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CumsumRealized is cumulative sum of network power capped by BalinePower(epoch)")]),t._v("\n  CumsumRealized Spacetime\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# EffectiveNetworkTime is ceiling of real effective network time `theta` based on")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CumsumBaselinePower(theta) == CumsumRealizedPower")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Theta captures the notion of how much the network has progressed in its baseline")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# and in advancing network time.")]),t._v("\n  EffectiveNetworkTime ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# EffectiveBaselinePower is the baseline power at the EffectiveNetworkTime epoch")]),t._v("\n  EffectiveBaselinePower StoragePower\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The reward to be paid in per WinCount to block producers.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The actual reward total paid out depends on the number of winners in any round.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This value is recomputed every non-null epoch and used in the next non-null epoch.")]),t._v("\n  ThisEpochReward TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Smoothed ThisEpochReward")]),t._v("\n  ThisEpochRewardSmoothed "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" FilterEstimate\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The baseline power the network is targeting at st.Epoch")]),t._v("\n  ThisEpochBaselinePower StoragePower\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Epoch tracks for which epoch the Reward was computed")]),t._v("\n  Epoch ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# TotalMined tracks the total FIL awarded to block miners")]),t._v("\n  TotalMined TokenAmount\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# Alpha Beta Filter "position" (value) and "velocity" (rate of change of value) estimates')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Estimates are in Q.128 format")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FilterEstimate")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  PositionEstimate BigInt "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Q.128")]),t._v("\n  VelocityEstimate BigInt "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Q.128")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h3",{attrs:{id:"v2-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2-3"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("a",{attrs:{name:"rewardv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RewardV2State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CumsumBaseline is a target CumsumRealized needs to reach for EffectiveNetworkTime to increase")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CumsumBaseline and CumsumRealized are expressed in byte-epochs.")]),t._v("\n  CumsumBaseline Spacetime\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CumsumRealized is cumulative sum of network power capped by BaselinePower(epoch)")]),t._v("\n  CumsumRealized Spacetime\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# EffectiveNetworkTime is ceiling of real effective network time `theta` based on")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CumsumBaselinePower(theta) == CumsumRealizedPower")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Theta captures the notion of how much the network has progressed in its baseline")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# and in advancing network time.")]),t._v("\n  EffectiveNetworkTime ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# EffectiveBaselinePower is the baseline power at the EffectiveNetworkTime epoch")]),t._v("\n  EffectiveBaselinePower StoragePower\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The reward to be paid in per WinCount to block producers.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The actual reward total paid out depends on the number of winners in any round.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This value is recomputed every non-null epoch and used in the next non-null epoch.")]),t._v("\n  ThisEpochReward TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Smoothed ThisEpochReward")]),t._v("\n  ThisEpochRewardSmoothed FilterEstimate\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The baseline power the network is targeting at st.Epoch")]),t._v("\n  ThisEpochBaselinePower StoragePower\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Epoch tracks for which epoch the Reward was computed")]),t._v("\n  Epoch ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# TotalStoragePowerReward tracks the total FIL awarded to block miners")]),t._v("\n  TotalStoragePowerReward TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Simple and Baseline totals are constants used for computing rewards.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# They are on chain because of a historical fix resetting baseline value")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# in a way that depended on the history leading immediately up to the")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# migration fixing the value.  These values can be moved from state back")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# into a code constant in a subsequent upgrade.")]),t._v("\n  SimpleTotal BigInt\n  BaselineTotal BigInt\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h2",{attrs:{id:"accountactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#accountactor"}},[t._v("#")]),t._v(" AccountActor")]),t._v(" "),s("p",[t._v("The CronActor state is the same in v0 and v2 and only contains an "),s("code",[t._v("Address")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"v0-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0-4"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"accountv0state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Address Address\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h3",{attrs:{id:"v2-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2-4"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("em",[t._v("(Same as v0)")])]),t._v(" "),s("p",[s("a",{attrs:{name:"accountv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AccountV2State")])]),t._v(" AccountV0State\n")])])]),s("h2",{attrs:{id:"storagemarketactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#storagemarketactor"}},[t._v("#")]),t._v(" StorageMarketActor")]),t._v(" "),s("p",[t._v("The StorageMarketActor state is the same in v0 and v2.")]),t._v(" "),s("h3",{attrs:{id:"v0-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0-5"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"marketv0state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MarketV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Proposals "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DealProposalAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[DealID]DealProposal")]),t._v("\n  States "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DealStateAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[DealID]DealState")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# PendingProposals tracks dealProposals that have not yet reached their deal start date.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# We track them here to ensure that miners can't publish the same deal proposal twice.")]),t._v("\n  PendingProposals "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DealProposalHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT[DealCid]DealProposal")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Total amount held in escrow, indexed by actor address (including both locked and unlocked amounts).")]),t._v("\n  EscrowTable "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BalanceTableHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT[Address]TokenAmount")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Amount locked, indexed by actor address.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Note: the amounts in this table do not affect the overall amount in escrow:")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# only the _portion_ of the total escrow amount that is locked.")]),t._v("\n  LockedTable "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BalanceTableHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT[Address]TokenAmount")]),t._v("\n  NextID DealID\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Metadata cached for efficient iteration over deals.")]),t._v("\n  DealOpsByEpoch "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DealOpsByEpochHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# SetMultimap: HAMT[ChainEpoch]Set[DealID]")]),t._v("\n  LastCron ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Total Client Collateral that is locked -> unlocked when deal is terminated")]),t._v("\n  TotalClientLockedCollateral TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Total Provider Collateral that is locked -> unlocked when deal is terminated")]),t._v("\n  TotalProviderLockedCollateral TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Total storage fee that is locked in escrow -> unlocked when payments are made")]),t._v("\n  TotalClientStorageFee TokenAmount\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h3",{attrs:{id:"v2-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2-5"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("em",[t._v("(Same as v0)")])]),t._v(" "),s("p",[s("a",{attrs:{name:"marketv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MarketV2State")])]),t._v(" MarketV0State\n")])])]),s("p",[s("strong",[t._v("AMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type DealProposalList [DealProposal]")]),t._v(", indexed by "),s("code",[t._v("DealID")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealProposalAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node DealProposalAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealProposalAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DealProposalAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("MarketV0DealProposal"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# inline")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MarketV0DealProposal")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CommP: A CID with fil-commitment-unsealed + sha2_256-trunc254-padded")]),t._v("\n  PieceCID "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("Any\n  PieceSize PaddedPieceSize\n  VerifiedDeal Bool\n  Client Address\n  Provider Address\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# An arbitrary client chosen label to apply to the deal")]),t._v("\n  Label String\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Nominal start epoch. Deal payment is linear between StartEpoch and EndEpoch,")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# with total amount StoragePricePerEpoch * (EndEpoch - StartEpoch).")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Storage deal must appear in a sealed (proven) sector no later than StartEpoch,")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# otherwise it is invalid.")]),t._v("\n  StartEpoch ChainEpoch\n  EndEpoch ChainEpoch\n  StoragePricePerEpoch TokenAmount\n  ProviderCollateral TokenAmount\n  ClientCollateral TokenAmount\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("AMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type DealProposalList [DealState]")]),t._v(", indexed by "),s("code",[t._v("DealID")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealStateAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node DealStateAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealStateAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DealStateAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("MarketV0DealState"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# inline")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MarketV0DealState")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  SectorStartEpoch ChainEpoch "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -1 if not yet included in proven sector")]),t._v("\n  LastUpdatedEpoch ChainEpoch "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -1 if deal state never updated")]),t._v("\n  SlashEpoch ChainEpoch "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# -1 if deal never slashed")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("HAMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type DealProposalMap {DealCidBytes:DealProposal}")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The bytes form of the the CID of a `MarketV0DealProposal` object as a block")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealCidBytes")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bytes")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealProposalHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" DealProposalHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealProposalHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" DealProposalHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Bucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealProposalHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DealProposalHAMT\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealProposalHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" DealProposalHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealProposalHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key DealCidBytes\n  value MarketV0DealProposal\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("HAMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type BalanceTable {Address:TokenAmount}")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BalanceTableHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" BalanceTableHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BalanceTableHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" BalanceTableHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" BalanceTableHAMTBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BalanceTableHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BalanceTableHAMT\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BalanceTableHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" BalanceTableHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BalanceTableHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key Address\n  value TokenAmount\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("SetMultimap (HAMT+HAMT)")]),t._v(": This is an ADL representing a Set within a Map "),s("code",[t._v("type DealOpsByEpoch {ChainEpochBytes:{DealIDBytes:Null}}")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT/map root structure")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealOpsByEpochHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" DealOpsByEpochHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealOpsByEpochHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" DealOpsByEpochHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" DealOpsByEpochHAMTBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealOpsByEpochHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DealOpsByEpochHAMTLink\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealOpsByEpochHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" DealOpsByEpochHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealOpsByEpochHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key ChainEpochBytes\n  value "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DealOpsByEpochAMT\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT/set leaf structure (map of nulls)")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealOpsByEpochHAMTSet")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" DealOpsByEpochHAMTSetElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealOpsByEpochHAMTSetElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" DealOpsByEpochHAMTSet_Link "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" DealOpsByEpochHAMTSetBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealOpsByEpochHAMTSet_Link")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DealOpsByEpochHAMTSet\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealOpsByEpochHAMTSetBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" DealOpsByEpochHAMTSetBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DealOpsByEpochHAMTSetBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key DealIDBytes\n  value Null\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h2",{attrs:{id:"storagemineractor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#storagemineractor"}},[t._v("#")]),t._v(" StorageMinerActor")]),t._v(" "),s("h3",{attrs:{id:"v0-6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0-6"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"minerv0state"}})]),t._v(" "),s("blockquote",[s("p",[t._v("Balance of Miner Actor should be greater than or equal to\nthe sum of PreCommitDeposits and LockedFunds.\nIt is possible for balance to fall below the sum of\nPCD, LF and InitialPledgeRequirements, and this is a bad\nstate (IP Debt) that limits a miner actor's behavior (i.e. no balance withdrawals)\nExcess balance as computed by st.GetAvailableBalance will be\nwithdrawable or usable for pre-commit deposit or pledge lock-up.")])]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Information not related to sectors")]),t._v("\n  Info  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0Info\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Total funds locked as PreCommitDeposits")]),t._v("\n  PreCommitDeposits TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Total rewards and added funds locked in vesting table")]),t._v("\n  LockedFunds TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# VestingFunds (Vesting Funds schedule for the miner)")]),t._v("\n  VestingFunds "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0VestingFunds\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sum of initial pledge requirements of all active sectors")]),t._v("\n  InitialPledge TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sectors that have been pre-committed but not yet proven.")]),t._v("\n  PreCommittedSectors "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0SectorPreCommitOnChainInfoHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT[SectorNumber]SectorPreCommitOnChainInfo")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# PreCommittedSectorsExpiry maintains the state required to expire PreCommittedSectors")]),t._v("\n  PreCommittedSectorsExpiry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BitFieldQueueAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[ChainEpoch]BitField")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Allocated sector IDs. Sector IDs can never be reused once allocated")]),t._v("\n  AllocatedSectors "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Information for all proven and not-yet-garbage-collected sectors.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sectors are removed from this AMT when the partition to which the")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# sector belongs is compacted.")]),t._v("\n  Sectors "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0SectorOnChainInfoAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[SectorNumber]SectorOnChainInfo")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The first epoch in this miner's current proving period. This is the first epoch in which a PoSt for a")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# partition at the miner's first deadline may arrive. Alternatively, it is after the last epoch at which")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# a PoSt for the previous window is valid.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Always greater than zero, this may be greater than the current epoch for genesis miners in the first")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# WPoStProvingPeriod epochs of the chain; the epochs before the first proving period starts are exempt from Window")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# PoSt requirements.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Updated at the end of every period by a cron callback.")]),t._v("\n  ProvingPeriodStart ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Index of the deadline within the proving period beginning at ProvingPeriodStart that has not yet been")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# finalized.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Updated at the end of each deadline window by a cron callback.")]),t._v("\n  CurrentDeadline Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The sector numbers due for PoSt at each deadline in the current proving period, frozen at period start.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# New sectors are added and expired ones removed at proving period boundary.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Faults are not subtracted from this in state, but on the fly.")]),t._v("\n  Deadlines "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0Deadlines\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Deadlines with outstanding fees for early sector termination")]),t._v("\n  EarlyTerminations BitField\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0Info")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Account that owns this miner.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# - Income and returned collateral are paid to this address.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# - This address is also allowed to change the worker address for the miner.")]),t._v("\n  Owner Address "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Must be an ID-address")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Worker account for this miner.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The associated pubkey-type address is used to sign blocks and messages on behalf of this miner.")]),t._v("\n  Worker Address "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Must be an ID-address.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Additional addresses that are permitted to submit messages controlling this actor (optional)")]),t._v("\n  ControlAddresses "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  PendingWorkerKey "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" MinerV0WorkerKeyChange\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Byte array representing a Libp2p identity that should be used when connecting to this miner")]),t._v("\n  PeerId PeerID\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Slice of byte arrays representing Libp2p multi-addresses used for establishing a connection with this miner")]),t._v("\n  Multiaddrs "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Multiaddr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The proof type used by this miner for sealing sectors")]),t._v("\n  SealProofType Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Amount of space in each sector committed by this miner.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This is computed from the proof type and represented here redundantly.")]),t._v("\n  SectorSize SectorSize\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The number of sectors in each Window PoSt partition (proof).")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This is computed from the proof type and represented here redundantly.")]),t._v("\n  WindowPoStPartitionSectors Int\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0WorkerKeyChange")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  NewWorker Address "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Must be an ID address")]),t._v("\n  EffectiveAt ChainEpoch\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# VestingFunds represents the vesting table state for the miner.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# It is a slice of (VestingEpoch, VestingAmount).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The slice will always be sorted by the VestingEpoch.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0VestingFunds")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Funds "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("MinerV0VestingFund"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# VestingFund represents miner funds that will vest at the given epoch.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0VestingFund")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Epoch ChainEpoch\n  Amount TokenAmount\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Deadlines contains Deadline objects, describing the sectors due at the given")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# deadline and their state (faulty, terminated, recovering, etc.).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0Deadlines")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Due MinerV0DeadlineLinkList\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Must be 48 CIDs")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0DeadlineLinkList")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0Deadline"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Deadline holds the state for all sectors due at a specific deadline.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0Deadline")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Partitions in this deadline, in order.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The keys of this AMT are always sequential integers beginning with zero.")]),t._v("\n  Partitions "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0PartitionAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[PartitionNumber]Partition")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Maps epochs to partitions that _may_ have sectors that expire in or")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# before that epoch, either on-time or early as faults.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Keys are quantized to final epochs in each proving deadline.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# NOTE: Partitions MUST NOT be removed from this queue (until the")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# associated epoch has passed) even if they no longer have sectors")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# expiring at that epoch. Sectors expiring at this epoch may later be")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# recovered, and this queue will not be updated at that time.")]),t._v("\n  ExpirationEpochs "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BitFieldQueueAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[ChainEpoch]BitField")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Partitions numbers with PoSt submissions since the proving period started.")]),t._v("\n  PostSubmissions BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Partitions with sectors that terminated early.")]),t._v("\n  EarlyTerminations BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The number of non-terminated sectors in this deadline (incl faulty).")]),t._v("\n  LiveSectors Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The total number of sectors in this deadline (incl dead).")]),t._v("\n  TotalSectors Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Memoized sum of faulty power in partitions.")]),t._v("\n  FaultyPower MinerV0PowerPair\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h3",{attrs:{id:"v2-6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2-6"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("a",{attrs:{name:"minerv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Information not related to sectors")]),t._v("\n  Info  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV2Info\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Total funds locked as PreCommitDeposits")]),t._v("\n  PreCommitDeposits TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Total rewards and added funds locked in vesting table")]),t._v("\n  LockedFunds TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# VestingFunds (Vesting Funds schedule for the miner)")]),t._v("\n  VestingFunds "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0VestingFunds\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Absolute value of debt this miner owes from unpaid fees")]),t._v("\n  FeeDebt TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sum of initial pledge requirements of all active sectors")]),t._v("\n  InitialPledge TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sectors that have been pre-committed but not yet proven")]),t._v("\n  PreCommittedSectors "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0SectorPreCommitOnChainInfoHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT[SectorNumber]SectorPreCommitOnChainInfo")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# PreCommittedSectorsExpiry maintains the state required to expire PreCommittedSectors")]),t._v("\n  PreCommittedSectorsExpiry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BitFieldQueueAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[ChainEpoch]BitField")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Allocated sector IDs. Sector IDs can never be reused once allocated")]),t._v("\n  AllocatedSectors "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Information for all proven and not-yet-garbage-collected sectors.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sectors are removed from this AMT when the partition to which the")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# sector belongs is compacted.")]),t._v("\n  Sectors "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV2SectorOnChainInfoAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[SectorNumber]SectorOnChainInfo")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The first epoch in this miner's current proving period. This is the first epoch in which a PoSt for a")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# partition at the miner's first deadline may arrive. Alternatively, it is after the last epoch at which")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# a PoSt for the previous window is valid.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Always greater than zero, this may be greater than the current epoch for genesis miners in the first")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# WPoStProvingPeriod epochs of the chain; the epochs before the first proving period starts are exempt from Window")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# PoSt requirements.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Updated at the end of every period by a cron callback.")]),t._v("\n  ProvingPeriodStart ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Index of the deadline within the proving period beginning at ProvingPeriodStart that has not yet been")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# finalized.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Updated at the end of each deadline window by a cron callback.")]),t._v("\n  CurrentDeadline Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The sector numbers due for PoSt at each deadline in the current proving period, frozen at period start.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# New sectors are added and expired ones removed at proving period boundary.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Faults are not subtracted from this in state, but on the fly.")]),t._v("\n  Deadlines "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV2Deadlines\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Deadlines with outstanding fees for early sector termination")]),t._v("\n  EarlyTerminations BitField\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2Info")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Account that owns this miner.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# - Income and returned collateral are paid to this address.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# - This address is also allowed to change the worker address for the miner.")]),t._v("\n  Owner Address "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Must be an ID-address")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Worker account for this miner.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The associated pubkey-type address is used to sign blocks and messages on behalf of this miner.")]),t._v("\n  Worker Address "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Must be an ID-address")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Additional addresses that are permitted to submit messages controlling this actor (optional).")]),t._v("\n  ControlAddresses "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Must all be ID addresses")]),t._v("\n  PendingWorkerKey "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" MinerV0WorkerKeyChange\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Byte array representing a Libp2p identity that should be used when connecting to this miner.")]),t._v("\n  PeerId PeerID\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Slice of byte arrays representing Libp2p multi-addresses used for establishing a connection with this miner.")]),t._v("\n  Multiaddrs "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Multiaddr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The proof type used by this miner for sealing sectors.")]),t._v("\n  SealProofType Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Amount of space in each sector committed by this miner.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This is computed from the proof type and represented here redundantly.")]),t._v("\n  SectorSize SectorSize\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The number of sectors in each Window PoSt partition (proof).")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This is computed from the proof type and represented here redundantly.")]),t._v("\n  WindowPoStPartitionSectors Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The next epoch this miner is eligible for certain permissioned actor methods")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# and winning block elections as a result of being reported for a consensus fault.")]),t._v("\n  ConsensusFaultElapsed ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# A proposed new owner account for this miner.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Must be confirmed by a message from the pending address itself.")]),t._v("\n  PendingOwnerAddress "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" Address\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[t._v("Ssame form as "),s("code",[t._v("MinerV0Deadlines")]),t._v(" but the eventual link to "),s("code",[t._v("MinerV2Partition")]),t._v(" is different.")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Deadlines contains Deadline objects, describing the sectors due at the given")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# deadline and their state (faulty, terminated, recovering, etc.).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2Deadlines")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Due MinerV2DeadlineLinkList\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Must be 48 CIDs")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2DeadlineLinkList")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV2Deadline"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Deadline holds the state for all sectors due at a specific deadline.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2Deadline")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Partitions in this deadline, in order.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The keys of this AMT are always sequential integers beginning with zero.")]),t._v("\n  Partitions "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV2PartitionAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[PartitionNumber]Partition")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Maps epochs to partitions that _may_ have sectors that expire in or")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# before that epoch, either on-time or early as faults.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Keys are quantized to final epochs in each proving deadline.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# NOTE: Partitions MUST NOT be removed from this queue (until the")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# associated epoch has passed) even if they no longer have sectors")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# expiring at that epoch. Sectors expiring at this epoch may later be")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# recovered, and this queue will not be updated at that time.")]),t._v("\n  ExpirationEpochs "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BitFieldQueueAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[ChainEpoch]BitField")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Partitions numbers with PoSt submissions since the proving period started.")]),t._v("\n  PostSubmissions BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Partitions with sectors that terminated early.")]),t._v("\n  EarlyTerminations BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The number of non-terminated sectors in this deadline (incl faulty).")]),t._v("\n  LiveSectors Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The total number of sectors in this deadline (incl dead).")]),t._v("\n  TotalSectors Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Memoized sum of faulty power in partitions.")]),t._v("\n  FaultyPower MinerV0PowerPair\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("HAMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type SectorPreCommitOnChainInfoMap {SectorNumberBytes:SectorPreCommitOnChainInfo}")])]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0SectorPreCommitOnChainInfoHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" MinerV0SectorPreCommitOnChainInfoHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0SectorPreCommitOnChainInfoHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" MinerV0SectorPreCommitOnChainInfoHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" MinerV0SectorPreCommitOnChainInfoHAMTBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0SectorPreCommitOnChainInfoHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0SectorPreCommitOnChainInfoHAMT\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0SectorPreCommitOnChainInfoHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" MinerV0SectorPreCommitOnChainInfoHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0SectorPreCommitOnChainInfoHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key SectorNumberBytes\n  value MinerV0SectorPreCommitOnChainInfo "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# inline")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Information stored on-chain for a pre-committed sector")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0SectorPreCommitOnChainInfo")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Info MinerV0SectorPreCommitInfo\n  PreCommitDeposit TokenAmount\n  PreCommitEpoch ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Integral of active deals over sector lifetime")]),t._v("\n  DealWeight DealWeight\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Integral of active verified deals over sector lifetime")]),t._v("\n  VerifiedDealWeight DealWeight\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Information provided by a miner when pre-committing a sector")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0SectorPreCommitInfo")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  SealProof RegisteredSealProof\n  SectorNumber SectorNumber\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CommR: A CID with fil-commitment-sealed + poseidon-bls12_381-ac-fc1")]),t._v("\n  SealedCID "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("Any\n  SealRandEpoch ChainEpoch\n  DealIDs "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("DealID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  Expiration ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# Whether to replace a "committed capacity" no-deal sector (requires non-empty DealIDs)')]),t._v("\n  ReplaceCapacity Bool\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The committed capacity sector to replace, and it's deadline/partition location")]),t._v("\n  ReplaceSectorDeadline Int\n  ReplaceSectorPartition PartitionNumber\n  ReplaceSectorNumber SectorNumber\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("AMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type BitFieldQueue [BitField]")]),t._v(" indexed by "),s("code",[t._v("ChainEpoch")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BitFieldQueueAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node BitFieldQueueAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BitFieldQueueAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BitFieldQueueAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Bitfield"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("AMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type V0SectorOnChainInfoList [V0SectorOnChainInfo]")]),t._v(" indexed by "),s("code",[t._v("SectorNumber")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0SectorOnChainInfoAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node MinerV0SectorOnChainInfoAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0SectorOnChainInfoAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0SectorOnChainInfoAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("MinerV0SectorOnChainInfo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Information stored on-chain for a proven sector")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0SectorOnChainInfo")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  SectorNumber SectorNumber\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The seal proof type implies the PoSt proof/s")]),t._v("\n  SealProof RegisteredSealProof\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CommR: A CID with fil-commitment-sealed + poseidon-bls12_381-ac-fc1")]),t._v("\n  SealedCID "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("Any\n  DealIDs "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("DealID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Epoch during which the sector proof was accepted")]),t._v("\n  Activation ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Epoch during which the sector expires")]),t._v("\n  Expiration ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Integral of active deals over sector lifetime")]),t._v("\n  DealWeight DealWeight\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Integral of active verified deals over sector lifetime")]),t._v("\n  VerifiedDealWeight DealWeight\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Pledge collected to commit this sector")]),t._v("\n  InitialPledge TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Expected one day projection of reward for sector computed at activation time")]),t._v("\n  ExpectedDayReward TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Expected twenty day projection of reward for sector computed at activation time")]),t._v("\n  ExpectedStoragePledge TokenAmount\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("AMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type V2SectorOnChainInfoList [V2SectorOnChainInfo]")]),t._v(" indexed by "),s("code",[t._v("SectorNumber")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2SectorOnChainInfoAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node MinerV2SectorOnChainInfoAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2SectorOnChainInfoAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV2SectorOnChainInfoAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("MinerV2SectorOnChainInfo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Information stored on-chain for a proven sector")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2SectorOnChainInfo")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  SectorNumber SectorNumber\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The seal proof type implies the PoSt proof/s")]),t._v("\n  SealProof RegisteredSealProof\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CommR: A CID with fil-commitment-sealed + poseidon-bls12_381-ac-fc1")]),t._v("\n  SealedCID "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("Any\n  DealIDs "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("DealID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Epoch during which the sector proof was accepted")]),t._v("\n  Activation ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Epoch during which the sector expires")]),t._v("\n  Expiration ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Integral of active deals over sector lifetime")]),t._v("\n  DealWeight DealWeight\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Integral of active verified deals over sector lifetime")]),t._v("\n  VerifiedDealWeight DealWeight\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Pledge collected to commit this sector")]),t._v("\n  InitialPledge TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Expected one day projection of reward for sector computed at activation time")]),t._v("\n  ExpectedDayReward TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Expected twenty day projection of reward for sector computed at activation time")]),t._v("\n  ExpectedStoragePledge TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Age of sector this sector replaced or zero")]),t._v("\n  ReplacedSectorAge ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Day reward of sector this sector replace or zero")]),t._v("\n  ReplacedDayReward TokenAmount\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("AMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type MinerV0PartitionList [MinerV0Partition]")]),t._v(" indexed by "),s("code",[t._v("PartitionNumber")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0PartitionAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node MinerV0PartitionAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0PartitionAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0PartitionAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("MinerV0Partition"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0Partition")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sector numbers in this partition, including faulty and terminated sectors")]),t._v("\n  Sectors BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Subset of sectors detected/declared faulty and not yet recovered (excl. from PoSt).")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Faults ∩ Terminated = ∅")]),t._v("\n  Faults BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Subset of faulty sectors expected to recover on next PoSt")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Recoveries ∩ Terminated = ∅")]),t._v("\n  Recoveries BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Subset of sectors terminated but not yet removed from partition (excl. from PoSt)")]),t._v("\n  Terminated BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Maps epochs sectors that expire in or before that epoch.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# An expiration may be an "on-time" scheduled expiration, or early "faulty" expiration.')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Keys are quantized to last-in-deadline epochs.")]),t._v("\n  ExpirationsEpochs "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0ExpirationSetAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[ChainEpoch]ExpirationSet")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Subset of terminated that were before their committed expiration epoch, by termination epoch.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Termination fees have not yet been calculated or paid and associated deals have not yet been")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# canceled but effective power has already been adjusted.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Not quantized.")]),t._v("\n  EarlyTerminated "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BitFieldQueueAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[ChainEpoch]BitField")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Power of not-yet-terminated sectors (incl faulty)")]),t._v("\n  LivePower MinerV0PowerPair\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Power of currently-faulty sectors. FaultyPower <= LivePower.")]),t._v("\n  FaultyPower MinerV0PowerPair\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Power of expected-to-recover sectors. RecoveringPower <= FaultyPower.")]),t._v("\n  RecoveringPower MinerV0PowerPair\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Value type for a pair of raw and QA power")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0PowerPair")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Raw StoragePower\n  QA StoragePower\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("AMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type MinerV2PartitionList [MinerV2Partition]")]),t._v(" indexed by "),s("code",[t._v("PartitionNumber")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2PartitionAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node MinerV2PartitionAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2PartitionAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV2PartitionAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("MinerV2Partition"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV2Partition")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sector numbers in this partition, including faulty, unproven, and terminated sectors")]),t._v("\n  Sectors BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Unproven sectors in this partition. This bitfield will be cleared on")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# a successful window post (or at the end of the partition's next")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# deadline). At that time, any still unproven sectors will be added to")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# the faulty sector bitfield.")]),t._v("\n  Unproven BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Subset of sectors detected/declared faulty and not yet recovered (excl. from PoSt).")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Faults ∩ Terminated = ∅")]),t._v("\n  Faults BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Subset of faulty sectors expected to recover on next PoSt")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Recoveries ∩ Terminated = ∅")]),t._v("\n  Recoveries BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Subset of sectors terminated but not yet removed from partition (excl. from PoSt)")]),t._v("\n  Terminated BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Maps epochs sectors that expire in or before that epoch.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# An expiration may be an "on-time" scheduled expiration, or early "faulty" expiration.')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Keys are quantized to last-in-deadline epochs.")]),t._v("\n  ExpirationsEpochs "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0ExpirationSetAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[ChainEpoch]ExpirationSet")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Subset of terminated that were before their committed expiration epoch, by termination epoch.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Termination fees have not yet been calculated or paid and associated deals have not yet been")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# canceled but effective power has already been adjusted.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Not quantized.")]),t._v("\n  EarlyTerminated "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("BitFieldQueueAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[ChainEpoch]BitField")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Power of not-yet-terminated sectors (incl faulty & unproven)")]),t._v("\n  LivePower MinerV0PowerPair\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Power of yet-to-be-proved sectors (never faulty)")]),t._v("\n  UnprovenPower MinerV0PowerPair\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Power of currently-faulty sectors. FaultyPower <= LivePower.")]),t._v("\n  FaultyPower MinerV0PowerPair\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Power of expected-to-recover sectors. RecoveringPower <= FaultyPower.")]),t._v("\n  RecoveringPower MinerV0PowerPair\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("AMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type MinerV0ExpirationSetList [MinerV0ExpirationSet]")]),t._v(" indexed by "),s("code",[t._v("ChainEpoch")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0ExpirationSetAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node MinerV0ExpirationSetAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0ExpirationSetAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MinerV0ExpirationSetAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("MinerV0ExpirationSet"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ExpirationSet is a collection of sector numbers that are expiring, either due to")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# expected "on-time" expiration at the end of their life, or unexpected "early" termination')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# due to being faulty for too long consecutively.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Note that there is not a direct correspondence between on-time sectors and active power;")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# a sector may be faulty but expiring on-time if it faults just prior to expected termination.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Early sectors are always faulty, and active power always represents on-time sectors.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MinerV0ExpirationSet")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# Sectors expiring "on time" at the end of their committed life')]),t._v("\n  OnTimeSectors BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# Sectors expiring "early" due to being faulty for too long')]),t._v("\n  EarlySectors BitField\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Pledge total for the on-time sectors")]),t._v("\n  OnTimePledge TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Power that is currently active (not faulty)")]),t._v("\n  ActivePower MinerV0PowerPair\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Power that is currently faulty")]),t._v("\n  FaultyPower MinerV0PowerPair\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h2",{attrs:{id:"multisigactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#multisigactor"}},[t._v("#")]),t._v(" MultisigActor")]),t._v(" "),s("p",[t._v("The MultisigActor state is the same in v0 and v2.")]),t._v(" "),s("h3",{attrs:{id:"v0-7"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0-7"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"multisigv0state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MultisigV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Signers may be either public-key or actor ID-addresses. The ID address is canonical, but doesn't exist")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# for a public key that has not yet received a message on chain.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# If any signer address is a public-key address, it will be resolved to an ID address and persisted")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# in this state when the address is used.")]),t._v("\n  Signers "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  NumApprovalsThreshold Int\n  NextTxnID TransactionID\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Linear unlock")]),t._v("\n  InitialBalance TokenAmount\n  StartEpoch ChainEpoch\n  UnlockDuration ChainEpoch\n  PendingTxns "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MultisigV0TransactionHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT[TransactionID]Multisigv0Transaction")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h3",{attrs:{id:"v2-7"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2-7"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("em",[t._v("(Same as v0)")])]),t._v(" "),s("p",[s("a",{attrs:{name:"multisigv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MultisigV2State")])]),t._v(" MultisigV0State\n")])])]),s("p",[s("strong",[t._v("HAMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type MultisigV0TransactionMap {TransactionIDBytes:MultisigV0Transaction}")])]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MultisigV0TransactionHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" MultisigV0TransactionHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MultisigV0TransactionHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" MultisigV0TransactionHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" MultisigV0TransactionHAMTBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MultisigV0TransactionHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("MultisigV0TransactionHAMT\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MultisigV0TransactionHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" MultisigV0TransactionHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MultisigV0TransactionHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key Bytes\n  value MultisigV0Transaction "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# inline")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MultisigV0Transaction")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  To Address\n  Value TokenAmount\n  Method MethodNum\n  Params CborEncodedParams\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This address at index 0 is the transaction proposer, order of this slice must be preserved.")]),t._v("\n  Approved "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h2",{attrs:{id:"paymentchannelactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#paymentchannelactor"}},[t._v("#")]),t._v(" PaymentChannelActor")]),t._v(" "),s("p",[t._v("The PaymentChannelActor state is the same in v0 and v2.")]),t._v(" "),s("h3",{attrs:{id:"v0-8"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0-8"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"paychv0state"}})]),t._v(" "),s("blockquote",[s("p",[t._v("A given payment channel actor is established by From\nto enable off-chain microtransactions to To to be reconciled\nand tallied on chain.")])]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PaychV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Channel owner, who has funded the actor")]),t._v("\n  From Address\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Recipient of payouts from channel")]),t._v("\n  To Address\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Amount successfully redeemed through the payment channel, paid out on `Collect()`")]),t._v("\n  ToSend BigInt\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Height at which the channel can be `Collected`")]),t._v("\n  SettlingAt ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Height before which the channel `ToSend` cannot be collected")]),t._v("\n  MinSettleHeight ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Collections of lane states for the channel, maintained in ID order.")]),t._v("\n  LaneStates "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PaychV0LaneStatesAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT[Int]PaychV0LaneState")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h3",{attrs:{id:"v2-8"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2-8"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("em",[t._v("(Same as v0)")])]),t._v(" "),s("p",[s("a",{attrs:{name:"paychv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PaychV2State")])]),t._v(" PaychV0State\n")])])]),s("p",[s("strong",[t._v("AMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type PaychV0LaneStates [PaychV0LaneState]")]),t._v(" indexed by Lane ID.")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PaychV0LaneStatesAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node PaychV0LaneStatesAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PaychV0LaneStatesAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PaychV0LaneStatesAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("PaychV0LaneState"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# The Lane state tracks the latest (highest) voucher nonce used to merge the lane")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# as well as the amount it has already redeemed.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PaychV0LaneState")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Redeemed BigInt\n  Nonce Int\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h2",{attrs:{id:"storagepoweractor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#storagepoweractor"}},[t._v("#")]),t._v(" StoragePowerActor")]),t._v(" "),s("p",[t._v("The StoragePowerActor state is the same in v0 and v2.")]),t._v(" "),s("h3",{attrs:{id:"v0-9"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0-9"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"powerv0state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  TotalRawBytePower StoragePower\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# TotalBytesCommitted includes claims from miners below min power threshold")]),t._v("\n  TotalBytesCommitted StoragePower\n  TotalQualityAdjPower StoragePower\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# TotalQABytesCommitted includes claims from miners below min power threshold")]),t._v("\n  TotalQABytesCommitted StoragePower\n  TotalPledgeCollateral TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# These fields are set once per epoch in the previous cron tick and used")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# for consistent values across a single epoch's state transition.")]),t._v("\n  ThisEpochRawBytePower StoragePower\n  ThisEpochQualityAdjPower StoragePower\n  ThisEpochPledgeCollateral TokenAmount\n  ThisEpochQAPowerSmoothed "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" FilterEstimate\n  MinerCount Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Number of miners having proven the minimum consensus power")]),t._v("\n  MinerAboveMinPowerCount Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# A queue of events to be triggered by cron, indexed by epoch")]),t._v("\n  CronEventQueue "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PowerV0CronEventHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Multimap: HAMT[ChainEpoch]AMT[PowerV0CronEvent]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# First epoch in which a cron task may be stored.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Cron will iterate every epoch between this and the current epoch inclusively to find tasks to execute.")]),t._v("\n  FirstCronEpoch ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Last epoch power cron tick has been processed")]),t._v("\n  LastProcessedCronEpoch ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Claimed power for each miner")]),t._v("\n  Claims "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PowerV0ClaimHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT[address]PowerV0Claim")]),t._v("\n  ProofValidationBatch "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("ProofValidationBatchHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Multimap: HAMT[Address]AMT[SealVerifyInfo]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h3",{attrs:{id:"v2-9"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2-9"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("a",{attrs:{name:"powerv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV2State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  TotalRawBytePower StoragePower\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# TotalBytesCommitted includes claims from miners below min power threshold")]),t._v("\n  TotalBytesCommitted StoragePower\n  TotalQualityAdjPower StoragePower\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# TotalQABytesCommitted includes claims from miners below min power threshold")]),t._v("\n  TotalQABytesCommitted StoragePower\n  TotalPledgeCollateral TokenAmount\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# These fields are set once per epoch in the previous cron tick and used")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# for consistent values across a single epoch's state transition.")]),t._v("\n  ThisEpochRawBytePower StoragePower\n  ThisEpochQualityAdjPower StoragePower\n  ThisEpochPledgeCollateral TokenAmount\n  ThisEpochQAPowerSmoothed FilterEstimate\n  MinerCount Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Number of miners having proven the minimum consensus power")]),t._v("\n  MinerAboveMinPowerCount Int\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# A queue of events to be triggered by cron, indexed by epoch")]),t._v("\n  CronEventQueue "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PowerV0CronEventHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Multimap: HAMT[ChainEpoch]AMT[PowerV0CronEvent]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# First epoch in which a cron task may be stored.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Cron will iterate every epoch between this and the current epoch inclusively to find tasks to execute.")]),t._v("\n  FirstCronEpoch ChainEpoch\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Claimed power for each miner")]),t._v("\n  Claims "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PowerV2ClaimHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT[address]PowerV2Claim")]),t._v("\n  ProofValidationBatch "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("ProofValidationBatchHAMT "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Multimap: HAMT[Address]AMT[SealVerifyInfo]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("Multimap (HAMT+AMT)")]),t._v(": This is an ADL representing a List within a Map "),s("code",[t._v("type PowerV0CronEventMap {ChainEpochBytes:[PowerV0CronEvent]}")]),t._v(", where the "),s("code",[t._v("CronEvent")]),t._v(" list is a queue.")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT/map root structure")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0CronEventHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" PowerV0CronEventHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0CronEventHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" PowerV0CronEventHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" PowerV0CronEventHAMTBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0CronEventHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PowerV0CronEventHAMTLink\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0CronEventHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" PowerV0CronEventHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0CronEventHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key ChainEpochBytes\n  value "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PowerV0CronEventAMT\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT/set leaf structure (list of CronEvents)")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0CronEventAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node PowerV0CronEventAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This can also be the root of a block")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0CronEventAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PowerV0CronEventAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("PowerV0CronEvent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0CronEvent")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  MinerAddr Address\n  CallbackPayload Bytes\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("HAMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type PowerV0ClaimMap {Address:PowerV0Claim}")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0ClaimMapHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" PowerV0ClaimMapHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0ClaimMapHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" PowerV0ClaimMapHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" PowerV0ClaimMapHAMTBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0ClaimMapHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PowerV0ClaimMapHAMT\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0ClaimMapHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" PowerV0ClaimMapHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0ClaimMapHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key Address\n  value PowerV0Claim\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV0Claim")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sum of raw byte power for a miner's sectors")]),t._v("\n  RawBytePower StoragePower\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sum of quality adjusted power for a miner's sectors")]),t._v("\n  QualityAdjPower StoragePower\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("HAMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type PowerV2ClaimMap {Address:PowerV2Claim}")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV2ClaimMapHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" PowerV2ClaimMapHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV2ClaimMapHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" PowerV2ClaimMapHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" PowerV2ClaimMapHAMTBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV2ClaimMapHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("PowerV2ClaimMapHAMT\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV2ClaimMapHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" PowerV2ClaimMapHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV2ClaimMapHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key Address\n  value PowerV2Claim\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PowerV2Claim")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Miner's proof type used to determine minimum miner size")]),t._v("\n  SealProofType RegisteredSealProof\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sum of raw byte power for a miner's sectors")]),t._v("\n  RawBytePower StoragePower\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Sum of quality adjusted power for a miner's sectors")]),t._v("\n  QualityAdjPower StoragePower\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("p",[s("strong",[t._v("Multimap (HAMT+AMT)")]),t._v(": This is an ADL representing a List within a Map "),s("code",[t._v("type ProofValidationBatchMap {Address:[SealVerifyInfo]}")]),t._v(", where "),s("code",[t._v("SealVerifyInfo")]),t._v(" is a queue.")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HAMT/map root structure")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ProofValidationBatchHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" ProofValidationBatchHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ProofValidationBatchHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ProofValidationBatchHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ProofValidationBatchHAMTBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ProofValidationBatchHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("ProofValidationBatchHAMTLink\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ProofValidationBatchHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" ProofValidationBatchHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ProofValidationBatchHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key Address\n  value "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("ProofValidationBatchAMT\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# AMT/set leaf structure (list of CronEvents)")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ProofValidationBatchAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  height Int\n  count Int\n  node ProofValidationBatchAMTNode\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This can also be the root of a block")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ProofValidationBatchAMTNode")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bitmap Bytes\n  children "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("ProofValidationBatchAMTNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  values "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("SealVerifyInfo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Information needed to verify a seal proof.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SealVerifyInfo")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  SealProof RegisteredSealProof\n  SectorID SectorID\n  DealIDs "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("DealID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  Randomness Bytes\n  InteractiveRandomness Bytes\n  Proof Bytes\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Safe because we get those from the miner actor")]),t._v("\n  SealedCID "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("Any "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CommR: A CID with fil-commitment-sealed + poseidon-bls12_381-ac-fc1")]),t._v("\n  UnsealedCID "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("Any "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# CommD: A CID with fil-commitment-unsealed + sha2_256-trunc254-padded")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h2",{attrs:{id:"verifiedregistryactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#verifiedregistryactor"}},[t._v("#")]),t._v(" VerifiedRegistryActor")]),t._v(" "),s("p",[t._v("The VerifiedRegistryActor state is the same in v0 and v2.")]),t._v(" "),s("h3",{attrs:{id:"v0-10"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0-10"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"verifregv0state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VerifregV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Root key holder multisig.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Authorize and remove verifiers.")]),t._v("\n  RootKey Address\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Verifiers authorize VerifiedClients.")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Verifiers delegate their DataCap.")]),t._v("\n  Verifiers "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DataCapHAMT\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# VerifiedClients can add VerifiedClientData, up to DataCap.")]),t._v("\n  VerifiedClients "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DataCapHAMT\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"v2-10"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2-10"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("em",[t._v("(Same as v0)")])]),t._v(" "),s("p",[s("a",{attrs:{name:"verifregv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VerifregV2State")])]),t._v(" VerifregV0State\n")])])]),s("p",[s("strong",[t._v("HAMT")]),t._v(": This is an ADL representing "),s("code",[t._v("type DataCapMap {Address:StoragePower}")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DataCapHAMT")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  map Bytes\n  data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" DataCapHAMTElement "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DataCapHAMTElement")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" DataCapHAMTLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0"')]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" DataCapHAMTBucket "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DataCapHAMTLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("DataCapHAMT\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DataCapHAMTBucket")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" DataCapHAMTBucketEntry "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DataCapHAMTBucketEntry")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  key Address\n  value DataCap "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# inline")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h2",{attrs:{id:"systemactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#systemactor"}},[t._v("#")]),t._v(" SystemActor")]),t._v(" "),s("p",[t._v("Note that "),s("code",[t._v("SystemV0State")]),t._v(" is an empty struct, which encodes as an empty CBOR array ("),s("code",[t._v("0x80")]),t._v(").")]),t._v(" "),s("p",[t._v("The SystemActor state is the same in v0 and v2.")]),t._v(" "),s("h3",{attrs:{id:"v0-11"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v0-11"}},[t._v("#")]),t._v(" v0")]),t._v(" "),s("p",[s("a",{attrs:{name:"systemv0state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SystemV0State")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" tuple\n")])])]),s("h3",{attrs:{id:"v2-11"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v2-11"}},[t._v("#")]),t._v(" v2")]),t._v(" "),s("p",[s("em",[t._v("(Same as v0)")])]),t._v(" "),s("p",[s("a",{attrs:{name:"systemv2state"}})]),t._v(" "),s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SystemV2State")])]),t._v(" SystemV0State\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);