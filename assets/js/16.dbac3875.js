(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{284:function(e,t,r){"use strict";r.r(t);var a=r(13),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("!!!")]),e._v(" "),r("p",[e._v("This document has "),r("strong",[e._v("moved")]),e._v(".")]),e._v(" "),r("p",[e._v("You'll now find information like this in the "),r("a",{attrs:{href:"https://github.com/ipld/ipld/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ipld/ipld"),r("OutboundLink")],1),e._v(" meta-repo,\nand published to the web at https://ipld.io/ .")]),e._v(" "),r("p",[e._v("All documentation, fixtures, specifications, and web content is now gathered into that repo.\nPlease update your links, and direct new contributions there.")]),e._v(" "),r("p",[e._v("!!!")]),e._v(" "),r("hr"),e._v(" "),r("h1",{attrs:{id:"specification-dag-cbor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#specification-dag-cbor"}},[e._v("#")]),e._v(" Specification: DAG-CBOR")]),e._v(" "),r("p",[r("strong",[e._v("Status: Descriptive - Draft")])]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#format"}},[e._v("Format")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#links"}},[e._v("Links")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#map-keys"}},[e._v("Map Keys")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#strictness"}},[e._v("Strictness")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#implementations"}},[e._v("Implementations")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#javascript"}},[e._v("JavaScript")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#go"}},[e._v("Go")])]),e._v(" "),r("li",[r("a",{attrs:{href:"#java"}},[e._v("Java")])])])]),e._v(" "),r("li",[r("a",{attrs:{href:"#limitations"}},[e._v("Limitations")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#javascript-numbers"}},[e._v("JavaScript Numbers")])])])])]),e._v(" "),r("p",[e._v("DAG-CBOR supports the full "),r("RouterLink",{attrs:{to:"/data-model-layer/data-model.html"}},[e._v("IPLD Data Model")]),e._v(".")],1),e._v(" "),r("p",[e._v("DAG-CBOR uses the "),r("a",{attrs:{href:"https://cbor.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concise Binary Object Representation (CBOR)"),r("OutboundLink")],1),e._v(" data format, defined by "),r("a",{attrs:{href:"https://tools.ietf.org/html/rfc8949",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 8949"),r("OutboundLink")],1),e._v(" (formerly "),r("a",{attrs:{href:"https://tools.ietf.org/html/rfc7049",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 7049"),r("OutboundLink")],1),e._v("), which natively supports all "),r("RouterLink",{attrs:{to:"/data-model-layer/data-model.html#kinds"}},[e._v("IPLD Data Model Kinds")]),e._v(".")],1),e._v(" "),r("h2",{attrs:{id:"format"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#format"}},[e._v("#")]),e._v(" Format")]),e._v(" "),r("p",[e._v("The CBOR IPLD format is called DAG-CBOR to disambiguate it from regular CBOR. Most simple CBOR objects are valid DAG-CBOR. The primary differences are:")]),e._v(" "),r("ul",[r("li",[e._v("Tag "),r("code",[e._v("42")]),e._v(" interpreted as CIDs, no other tags are supported.")]),e._v(" "),r("li",[e._v("Maps may only be keyed by strings.")]),e._v(" "),r("li",[e._v("Additional strictness requirements are applied to ensure canonical data encoding forms. See "),r("a",{attrs:{href:"#strictness"}},[e._v("Strictness")]),e._v(" below.")])]),e._v(" "),r("h2",{attrs:{id:"links"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[e._v("#")]),e._v(" Links")]),e._v(" "),r("p",[e._v("In DAG-CBOR, "),r("RouterLink",{attrs:{to:"/data-model-layer/data-model.html#link-kind"}},[e._v("Links")]),e._v(" are the binary form of a "),r("RouterLink",{attrs:{to:"/block-layer/CID.html"}},[e._v("CID")]),e._v(" encoded using the raw-binary identity "),r("a",{attrs:{href:"https://github.com/multiformats/multibase",target:"_blank",rel:"noopener noreferrer"}},[e._v("Multibase"),r("OutboundLink")],1),e._v(". That is, the Multibase identity prefix ("),r("code",[e._v("0x00")]),e._v(") is prepended to the binary form of a CID and this new byte array is encoded into CBOR as a byte-string (major type 2), and associated with CBOR tag "),r("code",[e._v("42")]),e._v(".")],1),e._v(" "),r("p",[e._v("Tag "),r("code",[e._v("42")]),e._v(" is associated in the "),r("a",{attrs:{href:"https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml",target:"_blank",rel:"noopener noreferrer"}},[e._v("CBOR Tags Registry"),r("OutboundLink")],1),e._v(' as "IPLD content identifier" and is further defined in '),r("a",{attrs:{href:"https://github.com/ipld/cid-cbor/",target:"_blank",rel:"noopener noreferrer"}},[e._v("IPLD content identifiers (CIDs) in CBOR"),r("OutboundLink")],1),e._v(".")]),e._v(" "),r("p",[e._v("The inclusion of the Multibase prefix exists for historical reasons and the identity prefix "),r("em",[e._v("must not")]),e._v(" be omitted.")]),e._v(" "),r("h2",{attrs:{id:"map-keys"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#map-keys"}},[e._v("#")]),e._v(" Map Keys")]),e._v(" "),r("p",[e._v("In DAG-CBOR, map keys must be strings, as defined by the "),r("RouterLink",{attrs:{to:"/data-model-layer/data-model.html"}},[e._v("IPLD Data Model")]),e._v(". Other map keys, such as ints, are not supported and should be rejected when encountered.")],1),e._v(" "),r("h2",{attrs:{id:"strictness"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#strictness"}},[e._v("#")]),e._v(" Strictness")]),e._v(" "),r("p",[e._v("DAG-CBOR requires that there exist a single, canonical way of encoding any given set of data, and that encoded forms contain no superfluous data that may be ignored or lost in a round-trip decode/encode.")]),e._v(" "),r("p",[e._v("Therefore the DAG-CBOR codec must:")]),e._v(" "),r("ol",[r("li",[e._v("Use no tags other than the CID tag ("),r("code",[e._v("42")]),e._v("). A valid DAG-CBOR encoder must not encode using any additional tags and a valid DAG-CBOR decoder must reject objects containing additional tags as invalid.\n"),r("ul",[r("li",[e._v("This includes any of the well defined tag numbers listed "),r("a",{attrs:{href:"https://tools.ietf.org/html/rfc8949#section-3.4",target:"_blank",rel:"noopener noreferrer"}},[e._v("section 3.4 of RFC 8949"),r("OutboundLink")],1),e._v(", such as dates, bignums, bigfloats, URIs, regular expressions and other complex, or simple values whether or not they map to the "),r("RouterLink",{attrs:{to:"/data-model-layer/data-model.html"}},[e._v("IPLD Data Model")]),e._v(".")],1)])]),e._v(" "),r("li",[e._v('Use the "Deterministically Encoded CBOR" rule suggestions defined in '),r("a",{attrs:{href:"https://tools.ietf.org/html/rfc8949#section-4.2",target:"_blank",rel:"noopener noreferrer"}},[e._v("section 4.2 of RFC 8949"),r("OutboundLink")],1),e._v(" except for map key ordering, which follow the original rules as defined in "),r("a",{attrs:{href:"https://tools.ietf.org/html/rfc7049#section-3.9",target:"_blank",rel:"noopener noreferrer"}},[e._v("section 3.9 of RFC 7049"),r("OutboundLink")],1),e._v(". Therefore, a valid DAG-CBOR encoder should produce encoded forms that adhere to the following rules, and a valid DAG-CBOR decoder should reject encoded forms not adhering to the following rules:\n"),r("ul",[r("li",[e._v("Integer encoding must be as short as possible.")]),e._v(" "),r("li",[e._v("The expression of lengths in major types 2 through 5 must be as short as possible.")]),e._v(" "),r("li",[e._v("The expression of tag numbers (specifically only "),r("code",[e._v("42")]),e._v(") must be as short as possible for major type 6. Therefore, for valid DAG-CBOR, the only tag token that can appear is "),r("code",[e._v("0xd82a")]),e._v(" - where "),r("code",[e._v("0xd8")]),e._v(' is "major type 6 with 8-bit integer to follow" and '),r("code",[e._v("0x2a")]),e._v(" is the number "),r("code",[e._v("42")]),e._v(".")]),e._v(" "),r("li",[e._v("The keys in every map must be sorted length-first by the byte representation of the string keys, where:\n"),r("ul",[r("li",[e._v("If two keys have different lengths, the shorter one sorts earlier;")]),e._v(" "),r("li",[e._v("If two keys have the same length, the one with the lower value in (byte-wise) lexical order sorts earlier.")])])]),e._v(" "),r("li",[e._v('Indefinite-length items are not supported, only definite-length items are usable. This includes strings, bytes, lists and maps. The "break" token is also not supported.')])])]),e._v(" "),r("li",[e._v("The only usable major type 7 minor types are those for encoding Floats (minors "),r("code",[e._v("25")]),e._v(", "),r("code",[e._v("26")]),e._v(", "),r("code",[e._v("27")]),e._v("), True (minor "),r("code",[e._v("20")]),e._v("), False (minor "),r("code",[e._v("21")]),e._v(") and Null (minor "),r("code",[e._v("22")]),e._v(").\n"),r("ul",[r("li",[r("a",{attrs:{href:"https://tools.ietf.org/html/rfc8949#section-2.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("Simple Values"),r("OutboundLink")],1),e._v(" other than True, False and Null are not supported. This includes all registered or unregistered simple values that are encoded with a major type 7 other than True, False and Null.")]),e._v(" "),r("li",[e._v("Undefined (minor "),r("code",[e._v("23")]),e._v(") is not supported as it is not part of the "),r("RouterLink",{attrs:{to:"/data-model-layer/data-model.html"}},[e._v("IPLD Data Model")]),e._v(".")],1)])]),e._v(" "),r("li",[e._v("Floating point values must always encoded in 64-bit, double-precision form, regardless of whether they can be represented as half (16) or single (32) precision.")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Floating-point_arithmetic",target:"_blank",rel:"noopener noreferrer"}},[e._v("IEEE 754"),r("OutboundLink")],1),e._v(" special values "),r("code",[e._v("NaN")]),e._v(", "),r("code",[e._v("Infinity")]),e._v(" and "),r("code",[e._v("-Infinity")]),e._v(" must not be accepted as they do not appear in the "),r("RouterLink",{attrs:{to:"/data-model-layer/data-model.html"}},[e._v("IPLD Data Model")]),e._v(". Therefore, tokens "),r("code",[e._v("0xf97c00")]),e._v(" ("),r("code",[e._v("Infinity")]),e._v("), "),r("code",[e._v("0xf97e00")]),e._v(" ("),r("code",[e._v("NaN")]),e._v(") and "),r("code",[e._v("0xf9fc00")]),e._v(" ("),r("code",[e._v("-Infinity")]),e._v("), their 16-bit, 32-bit and 64-bit variants, and any other "),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Floating-point_arithmetic",target:"_blank",rel:"noopener noreferrer"}},[e._v("IEEE 754"),r("OutboundLink")],1),e._v(" byte layout that is interpreted as these values, should not appear, or be accepted in DAG-CBOR binary form.")],1),e._v(" "),r("li",[e._v("Encode and decode must operate on a single top-level CBOR object. Back-to-back concatenated objects are not allowed or supported, as suggested by "),r("a",{attrs:{href:"https://tools.ietf.org/html/rfc8949#section-5.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("section 5.1 of RFC 8949"),r("OutboundLink")],1),e._v(" for "),r("em",[e._v("streaming applications")]),e._v(". All bytes of an encoded DAG-CBOR object must decode to a single object. Extraneous bytes included in an IPLD block, whether valid or invalid CBOR, must not be accepted as valid DAG-CBOR.")])]),e._v(" "),r("h2",{attrs:{id:"implementations"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#implementations"}},[e._v("#")]),e._v(" Implementations")]),e._v(" "),r("h3",{attrs:{id:"javascript"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[e._v("#")]),e._v(" JavaScript")]),e._v(" "),r("p",[r("strong",[r("a",{attrs:{href:"https://github.com/ipld/js-dag-cbor/",target:"_blank",rel:"noopener noreferrer"}},[e._v("@ipld/dag-cbor"),r("OutboundLink")],1)]),e._v(", for use with "),r("a",{attrs:{href:"https://github.com/multiformats/js-multiformats/",target:"_blank",rel:"noopener noreferrer"}},[e._v("multiformats"),r("OutboundLink")],1),e._v(" adheres to this specification, with the following caveats:")]),e._v(" "),r("ul",[r("li",[e._v("Complete strictness is not yet enforced on decode. Specifically: correct map ordering is not enforced and floats that are not encoded as 64-bit are not rejected.")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("BigInt")]),r("OutboundLink")],1),e._v(" is accepted along with "),r("code",[e._v("Number")]),e._v(' for encode, but the smallest-possible rule is followed when encoding. When decoding integers outside of the JavaScript "safe integer" range, a '),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("BigInt")]),r("OutboundLink")],1),e._v(" will be used.")])]),e._v(" "),r("p",[e._v("The legacy "),r("strong",[r("a",{attrs:{href:"https://github.com/ipld/js-ipld-dag-cbor/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ipld-dag-cbor"),r("OutboundLink")],1)]),e._v(" implementation adheres to this specification, with the following caveats:")]),e._v(" "),r("ul",[r("li",[e._v("Strictness is not enforced on decode; blocks encoded that do not follow the strictness rules are not rejected.")]),e._v(" "),r("li",[e._v("Floating point values are encoded as their smallest form rather than always 64-bit.")]),e._v(" "),r("li",[e._v("Many additional object types outside of the Data Model are currently accepted for decode and encode, including "),r("code",[e._v("undefined")]),e._v(".")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Floating-point_arithmetic",target:"_blank",rel:"noopener noreferrer"}},[e._v("IEEE 754"),r("OutboundLink")],1),e._v(" special values "),r("code",[e._v("NaN")]),e._v(", "),r("code",[e._v("Infinity")]),e._v(" and "),r("code",[e._v("-Infinity")]),e._v(" are accepted for decode and encode.")]),e._v(" "),r("li",[e._v('Integers outside of the JavaScript "safe integer" range will use the third-party '),r("a",{attrs:{href:"https://github.com/MikeMcl/bignumber.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("bignumber.js"),r("OutboundLink")],1),e._v(" library to represent their values.")])]),e._v(" "),r("p",[e._v("Note that inability to clearly differentiate between integers and floats in JavaScript may cause problems with round-trips of floating point values. See the "),r("RouterLink",{attrs:{to:"/data-model-layer/data-model.html"}},[e._v("IPLD Data Model")]),e._v(" and the discussion on "),r("a",{attrs:{href:"#limitations"}},[e._v("Limitations")]),e._v(" below for further discussion on JavaScript numbers and recommendations regarding the use of floats.")],1),e._v(" "),r("h3",{attrs:{id:"go"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#go"}},[e._v("#")]),e._v(" Go")]),e._v(" "),r("p",[r("strong",[r("a",{attrs:{href:"https://github.com/ipfs/go-ipld-cbor",target:"_blank",rel:"noopener noreferrer"}},[e._v("go-ipld-cbor"),r("OutboundLink")],1)]),e._v(" and "),r("strong",[r("a",{attrs:{href:"http://github.com/ipld/go-ipld-prime",target:"_blank",rel:"noopener noreferrer"}},[e._v("go-ipld-prime"),r("OutboundLink")],1)]),e._v(" adhere to this specification, with the following caveats:")]),e._v(" "),r("ul",[r("li",[e._v("Strictness is not enforced on decode; blocks encoded that do not follow the strictness rules are not rejected.")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Floating-point_arithmetic",target:"_blank",rel:"noopener noreferrer"}},[e._v("IEEE 754"),r("OutboundLink")],1),e._v(" special values "),r("code",[e._v("NaN")]),e._v(", "),r("code",[e._v("Infinity")]),e._v(" and "),r("code",[e._v("-Infinity")]),e._v(" are accepted for decode and encode.")])]),e._v(" "),r("h3",{attrs:{id:"java"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java"}},[e._v("#")]),e._v(" Java")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/Peergos/Peergos/tree/master/src/peergos/shared/cbor",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java IPLD from Peergos"),r("OutboundLink")],1),e._v(" adheres to this specification, with the following caveats:")]),e._v(" "),r("ul",[r("li",[e._v("Strictness is not enforced on decode; blocks encoded that do not follow the strictness rules are not rejected.")]),e._v(" "),r("li",[e._v("Floats are disabled.")])]),e._v(" "),r("h2",{attrs:{id:"limitations"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#limitations"}},[e._v("#")]),e._v(" Limitations")]),e._v(" "),r("h3",{attrs:{id:"javascript-numbers"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript-numbers"}},[e._v("#")]),e._v(" JavaScript Numbers")]),e._v(" "),r("p",[e._v("Users of DAG-CBOR that expect their data may be consumed or produced by JavaScript at some point should be aware of limitations that the language imposes on its use of DAG-CBOR, specifically concerning numbers.")]),e._v(" "),r("p",[e._v("All JavaScript numbers, both floating point and integer, (using the "),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("Number")]),r("OutboundLink")],1),e._v(" primitive wrapper) are represented internally as 64-bit "),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Floating-point_arithmetic",target:"_blank",rel:"noopener noreferrer"}},[e._v("IEEE 754"),r("OutboundLink")],1),e._v(" floating-point values (i.e. double-precision). Some implications within JavaScript of this design choice are:")]),e._v(" "),r("ul",[r("li",[e._v("There is no clear differentiation between a pure integer type and a floating-point number where a developer may wish to have such a differentiation.")]),e._v(" "),r("li",[e._v("By convention, JavaScript engines and developers usually omit the decimal point when representing whole numbers, simulating integers where the number is not actually stored as an integer.")]),e._v(" "),r("li",[e._v("There are limits on maximum and minimum safe integer sizes representable in JavaScript that are more constrained than those of languages where there are 64-bit integer types. Numbers outside of the range of "),r("code",[e._v("Number.MAX_SAFE_INTEGER")]),e._v(" ("),r("code",[e._v("2")]),r("sup",[r("code",[e._v("53")])]),r("code",[e._v("- 1")]),e._v(") and "),r("code",[e._v("Number.MIN_SAFE_INTEGER")]),e._v(" ("),r("code",[e._v("-(2")]),r("sup",[r("code",[e._v("53")])]),r("code",[e._v("- 1)")]),e._v(") cannot be safely manipulated or inspected as they incur rounding effects imposed by the "),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Floating-point_arithmetic",target:"_blank",rel:"noopener noreferrer"}},[e._v("IEEE 754"),r("OutboundLink")],1),e._v(" representation.")]),e._v(" "),r("li",[e._v('Native bit-wise operations on "integers" are not able to be performed outside of the 32-bit range; larger numbers will be truncated.')])]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/ipld/js-dag-cbor/",target:"_blank",rel:"noopener noreferrer"}},[e._v("@ipld/dag-cbor"),r("OutboundLink")],1),e._v(" supports "),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("BigInt")]),r("OutboundLink")],1),e._v(" for values outside of the safe integer range, while the legacy "),r("a",{attrs:{href:"https://github.com/ipld/js-ipld-dag-cbor/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ipld-dag-cbor"),r("OutboundLink")],1),e._v(" uses the third-party "),r("a",{attrs:{href:"https://github.com/MikeMcl/bignumber.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("bignumber.js"),r("OutboundLink")],1),e._v(" library to handle these values.")]),e._v(" "),r("p",[e._v("The implications for DAG-CBOR of these limitaitons are:")]),e._v(" "),r("ul",[r("li",[e._v("Any integer deserialized by the JavaScript CBOR decoder greater than "),r("code",[e._v("Number.MAX_SAFE_INTEGER")]),e._v(" or less than "),r("code",[e._v("Number.MIN_SAFE_INTEGER")]),e._v(" will be returned as a "),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("BigInt")]),r("OutboundLink")],1),e._v(" from "),r("a",{attrs:{href:"https://github.com/ipld/js-dag-cbor/",target:"_blank",rel:"noopener noreferrer"}},[e._v("@ipld/dag-cbor"),r("OutboundLink")],1),e._v(" or a "),r("a",{attrs:{href:"https://github.com/MikeMcl/bignumber.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("bignumber.js"),r("OutboundLink")],1),e._v(" wrapper type from "),r("a",{attrs:{href:"https://github.com/ipld/js-ipld-dag-cbor/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ipld-dag-cbor"),r("OutboundLink")],1),e._v(", which may be unexpected to users and have unexpected effects on downstream code.")]),e._v(" "),r("li",[e._v("Any "),r("code",[e._v("Number")]),e._v(" serialized by the JavaScript CBOR encoder relies on a whole-number check (i.e. "),r("code",[e._v("Number.isInteger()")]),e._v(", roughly "),r("code",[e._v("x % 1 === 0")]),e._v(") to determine whether it should be encoded as an integer or a float.")]),e._v(" "),r("li",[e._v("Any float deserialized by the JavaScript CBOR decoder that does not have a fractional component will be indistinguishable from an integer to a JavaScript program and may not round-trip to the same bytes if originally produced by non-JavaScript code.")]),e._v(" "),r("li",[e._v("Any "),r("code",[e._v("Number")]),e._v(" greater than "),r("code",[e._v("Number.MAX_SAFE_INTEGER")]),e._v(" or less than "),r("code",[e._v("Number.MIN_SAFE_INTEGER")]),e._v(" cannot be properly inspected for its whole-number status and is therefore encoded by the JavaScript CBOR encoder as float regardless of whether it is a whole-number or has a fractional component. "),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("BigInt")]),r("OutboundLink")],1),e._v(" should be used for "),r("a",{attrs:{href:"https://github.com/ipld/js-dag-cbor/",target:"_blank",rel:"noopener noreferrer"}},[e._v("@ipld/dag-cbor"),r("OutboundLink")],1),e._v(" when dealing with integers outside of the safe range to ensure proper handling.")])])])}),[],!1,null,null,null);t.default=o.exports}}]);