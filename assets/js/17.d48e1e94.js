(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{285:function(t,e,a){"use strict";a.r(e);var n=a(13),s=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("!!!")]),t._v(" "),a("p",[t._v("This document has "),a("strong",[t._v("moved")]),t._v(".")]),t._v(" "),a("p",[t._v("You'll now find information like this in the "),a("a",{attrs:{href:"https://github.com/ipld/ipld/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ipld/ipld"),a("OutboundLink")],1),t._v(" meta-repo,\nand published to the web at https://ipld.io/ .")]),t._v(" "),a("p",[t._v("All documentation, fixtures, specifications, and web content is now gathered into that repo.\nPlease update your links, and direct new contributions there.")]),t._v(" "),a("p",[t._v("!!!")]),t._v(" "),a("hr"),t._v(" "),a("h1",{attrs:{id:"specification-dag-jose"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification-dag-jose"}},[t._v("#")]),t._v(" Specification: DAG-JOSE")]),t._v(" "),a("p",[a("strong",[t._v("Status: Descriptive - Draft")])]),t._v(" "),a("p",[t._v("JOSE is a standard for signing and encrypting JSON objects. The various specifications for JOSE can be found in the "),a("a",{attrs:{href:"https://datatracker.ietf.org/wg/jose/documents/",target:"_blank",rel:"noopener noreferrer"}},[t._v("IETF datatracker"),a("OutboundLink")],1),t._v(".")]),t._v(" "),a("h2",{attrs:{id:"format"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#format"}},[t._v("#")]),t._v(" Format")]),t._v(" "),a("p",[t._v("The are two kinds of JOSE objects: JWS ("),a("a",{attrs:{href:"https://datatracker.ietf.org/doc/rfc7515/?include_text=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("JSON web signature"),a("OutboundLink")],1),t._v(") and JWE ("),a("a",{attrs:{href:"https://datatracker.ietf.org/doc/rfc7516/?include_text=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("JSON web encryption"),a("OutboundLink")],1),t._v("). These two objects are primitives in JOSE and can be used to create JWT and JWM objects etc. The IETF RFCs specify a JSON encoding of JOSE objects. This specification maps the JSON encoding to CBOR. Upon encountering the "),a("code",[t._v("dag-jose")]),t._v(" multiformat implementations can be sure that the block contains dag-cbor encoded data which matches the IPLD schema we specify below.")]),t._v(" "),a("h3",{attrs:{id:"mapping-from-the-jose-general-json-serialization-to-dag-jose-serialization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mapping-from-the-jose-general-json-serialization-to-dag-jose-serialization"}},[t._v("#")]),t._v(" Mapping from the JOSE general JSON serialization to dag-jose serialization")]),t._v(" "),a("p",[t._v("Both JWS and JWE supports three different serialization formats: "),a("code",[t._v("Compact Serialization")]),t._v(", "),a("code",[t._v("Flattened JSON Serialization")]),t._v(", and "),a("code",[t._v("General JSON Serialization")]),t._v(". The first two are more concise, but they only allow for one recipient. Therefore DAG JOSE always uses the "),a("code",[t._v("General Serialization")]),t._v(" which ensures maximum compatibility with minimum ambiguity. Libraries implementing serialization should accept all JOSE formats including the "),a("code",[t._v("Decoded Representation")]),t._v(" (see below) and convert them if necessary.")]),t._v(" "),a("p",[t._v("To map the general JSON serialization to CBOR we do the following:")]),t._v(" "),a("ul",[a("li",[t._v("Any field which is represented as "),a("code",[t._v("base64url(<data>)")]),t._v(" we map directly to "),a("code",[t._v("Bytes")]),t._v(" . For fields like "),a("code",[t._v("header")]),t._v(" and "),a("code",[t._v("protected")]),t._v(" which are specified as the "),a("code",[t._v("base64url(ascii(<some json>))")]),t._v(" that means that the value is the "),a("code",[t._v("ascii(<some json>)")]),t._v(" bytes.")]),t._v(" "),a("li",[t._v("For JWS we specify that the "),a("code",[t._v("payload")]),t._v(" property MUST be a CID, and we set the "),a("code",[t._v("payload")]),t._v(" of the encoded JOSE object to "),a("code",[t._v("Bytes")]),t._v(" containing the bytes of the CID. For applications where an additional network request to retrieve the linked content is undesirable then an "),a("code",[t._v("identity")]),t._v(" multihash should be used.")]),t._v(" "),a("li",[t._v("For JWE objects the "),a("code",[t._v("ciphertext")]),t._v(" must decrypt to a cleartext which is the bytes of a CID. This is for the same reason as the "),a("code",[t._v("payload")]),t._v(" being a CID, and the same approach of using an "),a("code",[t._v("identity")]),t._v(" multihash can be used, and most likely will be the only way to retain the confidentiality of data.")])]),t._v(" "),a("p",[t._v("Below we present an IPLD schema representing the encoded JOSE objects. Note that there are two IPLD schemas, "),a("code",[t._v("EncodedJWE")]),t._v(" and "),a("code",[t._v("EncodedJWS")]),t._v(". The actual wire format is a single struct which contains all the keys from both the "),a("code",[t._v("EncodedJWE")]),t._v(" and the "),a("code",[t._v("EncodedJWS")]),t._v(" structs, implementors should follow "),a("a",{attrs:{href:"https://tools.ietf.org/html/rfc7516#section-9",target:"_blank",rel:"noopener noreferrer"}},[t._v("section 9 of the JWE spec"),a("OutboundLink")],1),t._v(" and distinguish between these two branches by checking if the "),a("code",[t._v("payload")]),t._v(" attribute exists, and hence you have a JWS; or the "),a("code",[t._v("ciphertext")]),t._v(" attribute, hence you have a JWE.")]),t._v(" "),a("p",[a("strong",[t._v("Encoded JOSE")])]),t._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EncodedSignature")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  header "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  protected "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" Bytes\n  signature Bytes\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EncodedRecipient")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  encrypted_key "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" Bytes\n  header "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EncodedJWE")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  aad "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" Bytes\n  ciphertext Bytes\n  iv "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" Bytes\n  protected "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" Bytes\n  recipients "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("EncodedRecipient"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  tag "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" Bytes\n  unprotected "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EncodedJWS")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  payload "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" Bytes\n  signatures "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("EncodedSignature"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"padding-for-encryption"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#padding-for-encryption"}},[t._v("#")]),t._v(" Padding for encryption")]),t._v(" "),a("p",[t._v("Applications may need to pad the cleartext when encrypting to avoid leaking the size of the cleartext. This raises the question of how the application knows what part of the decrypted cleartext is padding. In this case we use the fact that the cleartext MUST be a valid CID, implementations should parse the cleartext as a CID and discard any content beyond the multihash digest size - which we assume to be the padding.")]),t._v(" "),a("h2",{attrs:{id:"decoded-jose"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#decoded-jose"}},[t._v("#")]),t._v(" Decoded JOSE")]),t._v(" "),a("p",[t._v("Typically implementations will want to decode this format into something more useful for applications. Exactly what that will look like depends on the language of the implementation, here we use the IPLD schema language to give a somewhat language agnostic description of what the decoded representation might look like at runtime. Note that everything which is specified as "),a("code",[t._v("base64url(ascii(<some JSON>))")]),t._v(" in the JOSE specs - and which we encode as "),a("code",[t._v("Bytes")]),t._v(" in the wire format - is here decoded to a "),a("code",[t._v("String")]),t._v(". We also add the "),a("code",[t._v("link: &Any")]),t._v(" attribute to the "),a("code",[t._v("DecodedJWS")]),t._v(",  which allows applications to easily retrieve the authenticated content.")]),t._v(" "),a("p",[t._v("Also note that, as with the encoded representation, there are two different representations; "),a("code",[t._v("DecodedJWE")]),t._v(" and "),a("code",[t._v("DecodedJWS")]),t._v(". Applications can distinguish between these two branches in the same way as with the Encoded representation described above.")]),t._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DecodedSignature")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  header "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  protected "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" String\n  signature String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DecodedJWS")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  payload String\n  signatures "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("DecodedSignature"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  link"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("&")]),t._v("Any\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DecodedRecipient")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  encrypted_key "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" String\n  header "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DecodedJWE")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  aad "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" String\n  ciphertext String\n  iv String\n  protected String\n  recipients "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("DecodedRecipient"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  tag String\n  unprotected "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"implementations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementations"}},[t._v("#")]),t._v(" Implementations")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/oed/js-dag-jose",target:"_blank",rel:"noopener noreferrer"}},[t._v("Javascript"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/alexjg/go-dag-jose",target:"_blank",rel:"noopener noreferrer"}},[t._v("Go"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=s.exports}}]);