(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{313:function(e,t,a){"use strict";a.r(t);var o=a(13),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("!!!")]),e._v(" "),a("p",[e._v("This document has "),a("strong",[e._v("moved")]),e._v(".")]),e._v(" "),a("p",[e._v("You'll now find information like this in the "),a("a",{attrs:{href:"https://github.com/ipld/ipld/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ipld/ipld"),a("OutboundLink")],1),e._v(" meta-repo,\nand published to the web at https://ipld.io/ .")]),e._v(" "),a("p",[e._v("All documentation, fixtures, specifications, and web content is now gathered into that repo.\nPlease update your links, and direct new contributions there.")]),e._v(" "),a("p",[e._v("!!!")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"specification-vector"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification-vector"}},[e._v("#")]),e._v(" Specification: Vector")]),e._v(" "),a("p",[a("strong",[e._v("Status: Prescriptive - Draft")])]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Introduction"}},[e._v("Introduction")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Useful-references"}},[e._v("Useful references")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Summary"}},[e._v("Summary")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Example"}},[e._v("Example")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Algorithmic-properties"}},[e._v("Algorithmic properties")])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Structure"}},[e._v("Structure")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Parameters"}},[e._v("Parameters")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Node-properties"}},[e._v("Node properties")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Schema"}},[e._v("Schema")])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Algorithm-in-detail"}},[e._v("Algorithm in detail")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Getindex"}},[a("code",[e._v("Get(index)")])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#PushTailvalue"}},[a("code",[e._v("PushTail(value)")])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Size"}},[a("code",[e._v("Size()")])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#CreateFromarray-width"}},[a("code",[e._v("CreateFrom(array, width)")])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Setindex-value"}},[a("code",[e._v("Set(index, value)")])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#PopTail"}},[a("code",[e._v("PopTail()")])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Full-copy-mutations-Deleteindex-PushHeadvalue-PopHead-Slicestart-end"}},[e._v("Full copy mutations: "),a("code",[e._v("Delete(index)")]),e._v(", "),a("code",[e._v("PushHead(value)")]),e._v(", "),a("code",[e._v("PopHead()")]),e._v(", "),a("code",[e._v("Slice(start, end)")])])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Implementation-defaults"}},[e._v("Implementation defaults")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Performance-profile"}},[e._v("Performance profile")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Possible-future-improvements-and-areas-for-research"}},[e._v("Possible future improvements and areas for research")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#Compression-for-sparse-arrays"}},[e._v("Compression for sparse arrays")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#Flexible-head-for-efficient-operations-a-the-head-and-for-sub-trees"}},[e._v("Flexible head for efficient operations a the head and for sub-trees")])])])])]),e._v(" "),a("h2",{attrs:{id:"introduction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),a("p",[e._v("The IPLD Vector distributes ordered-by-construction values across a tree structure with a pre-definable branching factor ("),a("code",[e._v("width")]),e._v(') that is consistent across all nodes in the tree. The tree defines node "height" rather than "depth", with the values stored in leaf nodes with a '),a("code",[e._v("height")]),e._v(" of "),a("code",[e._v("0")]),e._v(". All these leaf nodes are organized into a collection of "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("1")]),e._v(" nodes which contain links to the leaf nodes rather than values. We continue to increment "),a("code",[e._v("height")]),e._v(" until we have a single node as the root of the tree.")]),e._v(" "),a("p",[e._v("An IPLD Vector containing fewer values than the "),a("code",[e._v("width")]),e._v(" of the Vector can be represented by a single root node, with a "),a("code",[e._v("height")]),e._v(" of "),a("code",[e._v("0")]),e._v(" and a "),a("code",[e._v("data")]),e._v(" array containing only the values. Once an IPLD Vector expands beyond "),a("code",[e._v("width")]),e._v(", we add additional sibling "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("0")]),e._v(" nodes and reference them in a parent "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("1")]),e._v(" node. Once the "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("1")]),e._v(" node expands beyond "),a("code",[e._v("width")]),e._v(" child nodes, we perform the same operation by adding a new "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("2")]),e._v(" node to organize "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("1")]),e._v(" nodes.")]),e._v(" "),a("h2",{attrs:{id:"useful-references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#useful-references"}},[e._v("#")]),e._v(" Useful references")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://hypirion.com/musings/understanding-persistent-vector-pt-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("Understanding Clojure's Persistent Vectors, pt. 1"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://hypirion.com/musings/understanding-persistent-vector-pt-2",target:"_blank",rel:"noopener noreferrer"}},[e._v("pt. 2"),a("OutboundLink")],1),e._v(" are excellent introductions to some of the concepts covered here, including graphics that help describe the tree structures.")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://infoscience.epfl.ch/record/64394/files/triesearches.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Fast And Space Efficient Trie Searches"),a("OutboundLink")],1),e._v(" by Phil Bagwell, 2000, and "),a("a",{attrs:{href:"http://lampwww.epfl.ch/papers/idealhashtrees.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ideal Hash Trees"),a("OutboundLink")],1),e._v(" by Phil Bagwell, 2001, introduce the AMT and HAMT concepts, which has some similarity to the data structure described here.")]),e._v(" "),a("li",[e._v("Daniel Spiewak's Strange Loop '01 presentation titled "),a("a",{attrs:{href:"https://www.infoq.com/presentations/Functional-Data-Structures-in-Scala/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Extreme Cleverness: Functional Data Structures in Scala"),a("OutboundLink")],1),e._v(" covers the concept of Bitmapped Vector Tries, roughly equivalent to Clojure's Persistent Vector which is roughly the same as the data structure outlined here.")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/whyrusleeping/sharray",target:"_blank",rel:"noopener noreferrer"}},[e._v("sharray"),a("OutboundLink")],1),e._v(" a Go implementation of this data structure directly implemented against CBOR with Create and Iteration functionality.")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/rvagg/iavector",target:"_blank",rel:"noopener noreferrer"}},[e._v("iavector"),a("OutboundLink")],1),e._v(" the JavaScript reference implementation of this data structure.")])]),e._v(" "),a("h2",{attrs:{id:"summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[e._v("#")]),e._v(" Summary")]),e._v(" "),a("p",[e._v("IPLD Vector's algorithm is roughly based on the data structure used by "),a("a",{attrs:{href:"https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/PersistentVector.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("PersistentVector in Clojure"),a("OutboundLink")],1),e._v(" and referred to as a Bitmapped Vector Trie in "),a("a",{attrs:{href:"https://github.com/scala/scala/blob/v2.13.0/src/library/scala/collection/immutable/Vector.scala",target:"_blank",rel:"noopener noreferrer"}},[e._v("Scala's Vector"),a("OutboundLink")],1),e._v(". It has roots in the concept of Array Mapped Tries (AMT), as outlined in Phil Bagwell's "),a("a",{attrs:{href:"https://infoscience.epfl.ch/record/64394/files/triesearches.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("papers"),a("OutboundLink")],1),e._v(" on the "),a("a",{attrs:{href:"http://lampwww.epfl.ch/papers/idealhashtrees.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("subject"),a("OutboundLink")],1),e._v(". In these data structures, the indexing at each level of the trie comprises portions of the requested index. By taking advantage of efficient bitwise operations, we can slice an index into segments which point us through each level as we descend to the final value. The concept is roughly similar to slicing a hash as outlined in the "),a("RouterLink",{attrs:{to:"/data-structures/hashmap.html"}},[e._v("IPLD HashMap")]),e._v(" specification, except that we are slicing an index.")],1),e._v(" "),a("p",[e._v("One major difference with these data structures come from IPLD's minimal capacity to make use of the efficiencies afforded by bitwise operations. Without requiring bitwise operations, we don't have a strong need to align to byte or word boundaries and can use non-bitwise operations to perform our indexing function. Hence, the "),a("code",[e._v("width")]),e._v(" of the IPLD Vector is variable (not a power of "),a("code",[e._v("2")]),e._v(" as for the width of nodes in the "),a("RouterLink",{attrs:{to:"/data-structures/hashmap.html"}},[e._v("HashMap")]),e._v("), from a lower bound of "),a("code",[e._v("2")]),e._v(", for very tall trees that yield very small blocks, up to very large values that yield shallow trees but very large blocks. We leave the option of storing leaf values as CIDs or inline data up to the user, thereby affording the possibility of tuning "),a("code",[e._v("width")]),e._v(" to the desired block size with a traversal cost trade-off.")],1),e._v(" "),a("p",[e._v("IPLD Vectors don't implement a "),a("code",[e._v("map")]),e._v(" as in "),a("RouterLink",{attrs:{to:"/data-structures/hashmap.html"}},[e._v("HashMap")]),e._v(" or as may be used in an AMT to support compression for sparse arrays. It is assumed that most IPLD Vector usage will not be for sparse data and if sparse storage is needed that nodes containing empty "),a("code",[e._v("data")]),e._v(" array slots are acceptable. Note, however, that "),a("code",[e._v("Size")]),e._v(" does not account for empty elements in this data structure.")],1),e._v(" "),a("p",[e._v("A fully inlined option for this data structure is not presented here as this can be achieved by copying the data from an IPLD Vector into a new Vector whose "),a("code",[e._v("width")]),e._v(" is at least the "),a("code",[e._v("Size")]),e._v(" of the original and ensuring that values are inlined when stored. Therefore it is assumed that any nodes with "),a("code",[e._v("height")]),e._v(" greater than "),a("code",[e._v("0")]),e._v(" will have "),a("code",[e._v("data")]),e._v(" arrays containing only "),a("code",[e._v("CID")]),e._v("s which are links to child nodes.")]),e._v(" "),a("h3",{attrs:{id:"example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example"}},[e._v("#")]),e._v(" Example")]),e._v(" "),a("p",[e._v("For a "),a("code",[e._v("width")]),e._v(" of "),a("code",[e._v("3")]),e._v(", we can construct an tree to contain a series of values. In this case our values start with "),a("code",[e._v("1")]),e._v(" and increment for ease of example. Nodes will be indicated by lists of up to 3 items captured within "),a("code",[e._v("[")]),e._v(" and "),a("code",[e._v("]")]),e._v(".")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Height\n↓\n0:    [1 2 3]\n\n      Size: 3\n")])])]),a("p",[e._v("In this case, we have a single node containing the 3 values. "),a("code",[e._v("height")]),e._v(" for the node is "),a("code",[e._v("0")]),e._v(".")]),e._v(" "),a("p",[e._v("Appending two more values results in the following form:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Height\n↓\n1:            [a b]\n         ┌─────┘ │\n0:    [1 2 3] [4 5]\n\n      Size: 5\n      Max size before root overflow: 9\n      Head chain: a → 1\n      Tail chain: b → 5\n")])])]),a("p",[e._v("We now have two leaf nodes with "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("0")]),e._v(" containing our 5 values. Because they need to be stored in two nodes we add a "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("1")]),e._v(' node as our new root to contain links to them in appropriate order. We can also introduce the concept of a "head chain" and a "tail chain" as these become helpful in some operations on the data structure. The head chain points to the "head" node, or left-most if we conceive of our data nodes laid out from left to right in order. To navigate to the head we follow the head chain from the node containing '),a("code",[e._v("a")]),e._v(" to the node containing "),a("code",[e._v("1")]),e._v(". The tail chain leads from the same root node down to the node containing "),a("code",[e._v("5")]),e._v(".")]),e._v(" "),a("p",[e._v("We can fill up our "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("1")]),e._v(" node by adding 4 more values:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1:            [a b c]\n         ┌─────┘ │ └─────┐\n0:    [1 2 3] [4 5 6] [7 8 9]\n\n      Size: 9\n      Max size before root overflow: 9\n      Head chain: a → 1\n      Tail chain: c(full) → 9(full)\n")])])]),a("p",[e._v("Our tree is maximally full with a root node at "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("1")]),e._v(", any additional inserts will result in an overflow to "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("2")]),e._v(" to contain the data:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("2:                                       [A  B]\n                 ┌────────────────────────┘  │\n1:            [a b c]                    [d  e]\n         ┌─────┘ │ └─────┐        ┌───────┘  │\n0:    [1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]\n\n      Size: 15\n      Max size before root overflow: 27\n      Head chain: A → a → 1\n      Tail chain: B → e → 15(full)\n")])])]),a("p",[e._v("We now have 3 different heights, accessing any value requires traversal of two additional nodes beyond the root. We can see that this can be generalised such that the "),a("code",[e._v("height")]),e._v(" of the root node tells us the number of additional nodes required for a full traversal to any index.")]),e._v(" "),a("p",[e._v("Note that our \"overflow\" semantics don't just operate at the highest level of the tree, they also occur at intermediate levels. These overflows may or may not result in cascading overflows up the chain, most often they won't as the higher levels will have capacity to absorb new entries.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("2:                                       [A  B]\n                 ┌────────────────────────┘  │\n1:            [a b c]                    [d  e  f]\n         ┌─────┘ │ └─────┐        ┌───────┘  │  └────────┐\n0:    [1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15] [16 17 18]\n\n      Size: 18\n      Max size before root overflow: 27\n      Head chain: A → a → 1\n      Tail chain: B → f(full) → 18(full)\n")])])]),a("p",[e._v("At 27 items, we have a full "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("2")]),e._v(", "),a("code",[e._v("width")]),e._v(" "),a("code",[e._v("3")]),e._v(" tree:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("2:                                       [A  B  C]\n                ┌─────────────────────────┘  │  └─────────────────────────────┐\n1:            [a b c]                    [d  e  f]                        [g  h  i]\n         ┌─────┘ │ └─────┐        ┌───────┘  │  └────────┐         ┌───────┘  │  └────────┐\n0:    [1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15] [16 17 18] [19 20 21] [22 23 24] [25 26 27]\n\n      Size: 27\n      Max size before root overflow: 27\n      Head chain: A → a → 1\n      Tail chain: C(full) → i(full) → 27(full)\n")])])]),a("p",[e._v("An overflow adds an additional level and space for "),a("code",[e._v("width")]),a("sup",[a("code",[e._v("height+1")])]),e._v(", or "),a("code",[e._v("3")]),a("sup",[a("code",[e._v("4")])]),a("code",[e._v("= 81")]),e._v(" items.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("3:                                                                                              [i  ii]\n                                             ┌───────────────────────────────────────────────────┘  │\n2:                                       [A  B  C]                                                 [D]\n                ┌─────────────────────────┘  │  └─────────────────────────────┐                     │\n1:            [a b c]                    [d  e  f]                        [g  h  i]                [j]\n         ┌─────┘ │ └─────┐        ┌───────┘  │  └────────┐         ┌───────┘  │  └────────┐         │\n0:    [1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15] [16 17 18] [19 20 21] [22 23 24] [25 26 27] [28 29 30]\n\n      Size: 30\n      Max size before root overflow: 81\n      Head chain: i → A → a → 1\n      Tail chain: ii → D → j → 30(full)\n")])])]),a("h3",{attrs:{id:"algorithmic-properties"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#algorithmic-properties"}},[e._v("#")]),e._v(" Algorithmic properties")]),e._v(" "),a("p",[e._v("We can derive the "),a("strong",[e._v("maximum number of elements containable under a node and its children")]),e._v(" with a "),a("code",[e._v("height")]),e._v(" of "),a("code",[e._v("X")]),e._v(" with "),a("code",[e._v("width")]),a("sup",[a("code",[e._v("X + 1")])]),e._v(". At a "),a("code",[e._v("height")]),e._v(" of "),a("code",[e._v("0")]),e._v(", we can only fit "),a("code",[e._v("width")]),e._v(" elements into a single node. Add a "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("1")]),e._v(" parent and we can fit in "),a("code",[e._v("width")]),a("sup",[a("code",[e._v("2")])]),e._v(" elements across all child "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("0")]),e._v(" nodes underneath it. This calculation is useful for at least "),a("code",[e._v("Size")]),e._v(" and append (which we will call "),a("code",[e._v("PushTail")]),e._v(") operations.")]),e._v(" "),a("p",[a("strong",[e._v("Overflows")]),e._v(" during "),a("code",[e._v("PushTail")]),e._v(" operations do not always cascade to upper levels of the tree. Cascades only occur where an upper level is maximally full. So a cascade causing the addition of a new root level at "),a("code",[e._v("height + 1")]),e._v(" only happens when all levels are full.")]),e._v(" "),a("p",[a("strong",[e._v("All nodes are valid IPLD Vectors")]),e._v(", and as such may be extracted to represent slices of the overall parent data structure. This becomes less useful as we increase "),a("code",[e._v("width")]),e._v(", as the start index of a slice must align with a node boundary such that the new head node is a copy of an existing node. Otherwise all elements need to be shuffled toward the head, therefore mutating the entire data structure. Lack of alignment a the tail of a slice only requires mutations on the tail chain.")]),e._v(" "),a("p",[a("strong",[e._v("Copy-on-write semantics")]),e._v(" extend beyond slicing, as with other IPLD data structures, so that mutations require a minimal set of changes cascading up from the changed leaf ("),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("0")]),e._v(") node, up to the root node. Any single-value mutation, either "),a("code",[e._v("PushTail")]),e._v(" or "),a("code",[e._v("Replace")]),e._v(", require a replacement of a single node at each level of the tree.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1:            [a b c]  (old root node)\n         ┌─────┘ │ └─────┐\n0:    [1 2 3] [4 5 6] [7 8 9]\n\n\nReplace(5, X) → replace position 5 (value '6'), with a new value, 'X'\n\n1.1:                            [a Y c]  (new root node)\n         ┌───────────────────────┘ │ │\n1:       │    [a b c]    ┌─────────┼─┘\n         ├─────┘ │ └─────┤         │\n0:    [1 2 3] [4 5 6] [7 8 9]   [4 5 X]\n")])])]),a("h3",{attrs:{id:"canonical-form"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#canonical-form"}},[e._v("#")]),e._v(" Canonical form")]),e._v(" "),a("p",[e._v("Given any fixed set of ordered data and any particular "),a("code",[e._v("width")]),e._v(", an IPLD Vector will maintain a canonical form regardless of the construction method or any changes that take place to arrive at the final fixed set of ordered data. e.g. using a "),a("code",[e._v("CreateFrom")]),e._v(" on an array and using that same array to iteratively "),a("code",[e._v("PushTail")]),e._v(" the items into a Vector, both vectors will have the same properties and the root nodes will yield the same hash. This is also true if "),a("code",[e._v("Set")]),e._v(" operations are performed on the data as long as he final set of data is the same.")]),e._v(" "),a("p",[e._v("Varying "),a("code",[e._v("width")]),e._v(" always yields different root hashes regardless of data.")]),e._v(" "),a("h2",{attrs:{id:"structure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#structure"}},[e._v("#")]),e._v(" Structure")]),e._v(" "),a("h3",{attrs:{id:"parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("p",[e._v("The only configurable parameter of an IPLD Vector is the "),a("code",[e._v("width")]),e._v(". This parameter must be consistent across all nodes in a Vector. Mutations cannot involve changes in "),a("code",[e._v("width")]),e._v(" or joining multiple parts of a Vector with differing "),a("code",[e._v("width")]),e._v(" values.")]),e._v(" "),a("p",[a("code",[e._v("width")]),e._v(" must be an integer, of at least "),a("code",[e._v("2")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"node-properties"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-properties"}},[e._v("#")]),e._v(" Node properties")]),e._v(" "),a("p",[e._v("Each node in an IPLD vector stores the "),a("code",[e._v("width")]),e._v(", the "),a("code",[e._v("height")]),e._v(" of the node, starting from "),a("code",[e._v("0")]),e._v(" where values are stored, and a "),a("code",[e._v("data")]),e._v(" array to contain values (for "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("0")]),e._v("), or child node CIDs (for "),a("code",[e._v("height")]),e._v("s above "),a("code",[e._v("1")]),e._v(").")]),e._v(" "),a("h3",{attrs:{id:"schema"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#schema"}},[e._v("#")]),e._v(" Schema")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Vector")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  width Int\n  height Int\n  data "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" Value "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Value")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Link link\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Bool "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bool")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" String "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Bytes "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bytes")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Int "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Float "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("float")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Map map\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" List list\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" kinded\n")])])]),a("p",[a("strong",[e._v("Constraints:")])]),e._v(" "),a("ul",[a("li",[e._v("Non-leaf ("),a("code",[e._v("height")]),e._v(" greater than "),a("code",[e._v("0")]),e._v(") nodes only contain "),a("code",[e._v("Link")]),e._v("s to other "),a("code",[e._v("Vector")]),e._v(" nodes in their "),a("code",[e._v("data")]),e._v(" array.")]),e._v(" "),a("li",[a("code",[e._v("width")]),e._v(" must be consistent across all nodes in a Vector.")]),e._v(" "),a("li",[a("code",[e._v("height")]),e._v(" must be at least "),a("code",[e._v("0")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("data")]),e._v(" can contain between "),a("code",[e._v("1")]),e._v(" and "),a("code",[e._v("width")]),e._v(" elements. For the special case of the empty Vector, a single root node may have "),a("code",[e._v("0")]),e._v(" elements in "),a("code",[e._v("data")]),e._v(".")])]),e._v(" "),a("h2",{attrs:{id:"algorithm-in-detail"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-in-detail"}},[e._v("#")]),e._v(" Algorithm in detail")]),e._v(" "),a("h3",{attrs:{id:"get-index"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-index"}},[e._v("#")]),e._v(" "),a("code",[e._v("Get(index)")])]),e._v(" "),a("p",[a("code",[e._v("index")]),e._v(" is a zero-based in all cases.")]),e._v(" "),a("p",[a("code",[e._v("Get")]),e._v(" can either be implemented as a recursive or iterative process.")]),e._v(" "),a("ol",[a("li",[e._v("If "),a("code",[e._v("index")]),e._v(" is less than zero, return undefined or an OOB indication.")]),e._v(" "),a("li",[e._v("Calculate the maximum possible index for a tree with this "),a("code",[e._v("height")]),e._v(" using "),a("code",[e._v("width")]),a("sup",[a("code",[e._v("height + 1")])]),e._v(". If the index is greater than this maximum, returned undefined or an OOB indication.")]),e._v(" "),a("li",[e._v("Calculate the local "),a("code",[e._v("dataIndex")]),e._v(", the index of this node's "),a("code",[e._v("data")]),e._v(" array, using "),a("code",[e._v("floor(index / width")]),a("sup",[a("code",[e._v("height")])]),a("code",[e._v(")")]),e._v(".")]),e._v(" "),a("li",[e._v("If "),a("code",[e._v("dataIndex")]),e._v(" is greater than or equal to the length of this node's "),a("code",[e._v("data")]),e._v(" array, return undefined or an OOB indication.")]),e._v(" "),a("li",[e._v("If "),a("code",[e._v("height")]),e._v(" is "),a("code",[e._v("0")]),e._v(", return the element at the "),a("code",[e._v("dataIndex")]),e._v(" position of this node's "),a("code",[e._v("data")]),e._v(" array.")]),e._v(" "),a("li",[e._v("If "),a("code",[e._v("height")]),e._v(" is greater than "),a("code",[e._v("0")]),e._v(", retrieve the CID of the next node from the "),a("code",[e._v("dataIndex")]),e._v(" position of this node's "),a("code",[e._v("data")]),e._v(" array.")]),e._v(" "),a("li",[e._v("Recurse or iterate from Step 1 with the next node with "),a("code",[e._v("index")]),e._v(" set to "),a("code",[e._v("index % width")]),a("sup",[a("code",[e._v("height")])]),e._v(" to identify its place in the sub-tree.")])]),e._v(" "),a("h3",{attrs:{id:"pushtail-value"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pushtail-value"}},[e._v("#")]),e._v(" "),a("code",[e._v("PushTail(value)")])]),e._v(" "),a("p",[a("code",[e._v("PushTail")]),e._v(" appends "),a("code",[e._v("value")]),e._v(" to the tail of the data structure. This increases the Vector's "),a("code",[e._v("Size")]),e._v(" by "),a("code",[e._v("1")]),e._v(" and may cause zero or more overflows throughout the tree but will result in a single mutation at each "),a("code",[e._v("height")]),e._v(" of the Vector, including the root and possibly the creation of a new root node at "),a("code",[e._v("height + 1")]),e._v(" if an overflow cascades to the root.")]),e._v(" "),a("p",[e._v("This algorithm can be implemented as a recursive or iterative process. A recursive process will need to propagate additional state when mutating back up the tree from the mutated root.")]),e._v(" "),a("p",[e._v("In this algorithm, we keep a "),a("code",[e._v("mutated")]),e._v(" state variable to indicate whether there was a mutation while modifying the tail chain. In the case of a mutation we only need to "),a("em",[e._v("replace")]),e._v(" links to a child node so there are no overflows from this point upward. In addition, we reuse "),a("code",[e._v("value")]),e._v(" such that the first time it is used should be "),a("code",[e._v("height")]),e._v(" "),a("code",[e._v("0")]),e._v(" where it's the originally supplied "),a("code",[e._v("value")]),e._v(", but from that point back up the chain it becomes a link to a child node.")]),e._v(" "),a("ol",[a("li",[e._v('Collect the "tail chain" of nodes:\n'),a("ol",[a("li",[e._v("Append the root to the tail chain.")]),e._v(" "),a("li",[e._v("If the current node's "),a("code",[e._v("height")]),e._v(" is "),a("code",[e._v("0")]),e._v(".\n"),a("ol",[a("li",[e._v("The tail chain is complete, continue to step 2.")])])]),e._v(" "),a("li",[e._v("If the current node's "),a("code",[e._v("height")]),e._v(" is greater than "),a("code",[e._v("0")]),e._v(".\n"),a("ol",[a("li",[e._v("Locate the next tail node identified by the CID at the last position of the current node's "),a("code",[e._v("data")]),e._v(" array. Add it to the tail chain.")]),e._v(" "),a("li",[e._v("Repeat from step 1.ii with the next tail node.")])])])])]),e._v(" "),a("li",[e._v("Store a "),a("code",[e._v("mutated")]),e._v(" state variable, set initially to "),a("code",[e._v("false")]),e._v(".")]),e._v(" "),a("li",[e._v("If the tail chain contains at least one entry.\n"),a("ol",[a("li",[e._v('Pop the tail node of the tail chain as the "current node"\n'),a("ol",[a("li",[e._v("If the "),a("code",[e._v("mutated")]),e._v(" state variable is "),a("code",[e._v("true")]),e._v(" we only need to replace the link to a child node.\n"),a("ol",[a("li",[e._v("Create a copy of the current node, replacing the last element of the "),a("code",[e._v("data")]),e._v(" array of the copy with "),a("code",[e._v("value")]),e._v(". This is guaranteed to be at "),a("code",[e._v("height")]),e._v(" of at least "),a("code",[e._v("1")]),e._v(" since "),a("code",[e._v("mutated")]),e._v(" begins as "),a("code",[e._v("false")]),e._v(", so we are only replacing links to mutated nodes.")]),e._v(" "),a("li",[e._v("Repeat from step 3 with "),a("code",[e._v("value")]),e._v(" set to the CID of the mutated node.")])])]),e._v(" "),a("li",[e._v("If the length of the "),a("code",[e._v("data")]),e._v(" array at the current node is less than "),a("code",[e._v("width")]),e._v(", no overflow is necessary.\n"),a("ol",[a("li",[e._v("Create a copy of the current node, appending "),a("code",[e._v("value")]),e._v(" to the end of the "),a("code",[e._v("data")]),e._v(" array of the copy.")]),e._v(" "),a("li",[e._v("Set "),a("code",[e._v("mutated")]),e._v(" to "),a("code",[e._v("true")])]),e._v(" "),a("li",[e._v("Repeat from step 3 with "),a("code",[e._v("value")]),e._v(" set to the CID of the mutated node.")])])]),e._v(" "),a("li",[e._v("If the length of the "),a("code",[e._v("data")]),e._v(" array at the current node is "),a("code",[e._v("width")]),e._v(", an overflow is necessary.\n"),a("ol",[a("li",[e._v("Create a new node with the same "),a("code",[e._v("height")]),e._v(" as the current node and a "),a("code",[e._v("data")]),e._v(" array that only contains the single "),a("code",[e._v("value")]),e._v(".")]),e._v(" "),a("li",[e._v("Set the "),a("code",[e._v("mutated")]),e._v(" state variable to "),a("code",[e._v("false")]),e._v(".")]),e._v(" "),a("li",[e._v("Repeat from step 3 with "),a("code",[e._v("value")]),e._v(" set to the CID of the new node.")])])])])])])]),e._v(" "),a("li",[e._v("If the tail chain is empty (this does not occur on the first pass as the root is always in the tail chain).\n"),a("ol",[a("li",[e._v("If "),a("code",[e._v("mutated")]),e._v(" is still "),a("code",[e._v("false")]),e._v(", we have had cascading overflows up to the root so we need to add a new level to the Vector.\n"),a("ol",[a("li",[e._v("Create a new node with the original root node's "),a("code",[e._v("height + 1")]),e._v(", add two values to its "),a("code",[e._v("data")]),e._v(" array: the CID of the original root node and "),a("code",[e._v("value")]),e._v(" which will be the CID of a new, overflowed child node.")]),e._v(" "),a("li",[e._v("Return the CID of the new node, which becomes the new root node.")])])]),e._v(" "),a("li",[e._v("If "),a("code",[e._v("mutated")]),e._v(" is "),a("code",[e._v("true")]),e._v(" "),a("ol",[a("li",[e._v("Return "),a("code",[e._v("value")]),e._v(", which should be the CID of the last mutated node, which becomes the new root node.")])])])])])]),e._v(" "),a("h3",{attrs:{id:"size"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#size"}},[e._v("#")]),e._v(" "),a("code",[e._v("Size()")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("Size")]),e._v(" algorithm uses a subtractive process, first calculating the maximum potential size and then iterating through the tail chain to subtract known empty portions given varying "),a("code",[e._v("data")]),e._v(" array sizes at each "),a("code",[e._v("height")]),e._v(". If "),a("code",[e._v("data")]),e._v(" arrays are maximally full at each "),a("code",[e._v("height")]),e._v(" then the original maximum potential size calculation is used as the correct value.")]),e._v(" "),a("ol",[a("li",[e._v("Set "),a("code",[e._v("size")]),e._v(" to be the maximum potential size of the data structure with "),a("code",[e._v("width")]),a("sup",[a("code",[e._v("height + 1")])]),e._v(".")]),e._v(" "),a("li",[e._v("Calculate the number of empty potential value slots at this height with "),a("code",[e._v("width")]),a("sup",[a("code",[e._v("height")])]),a("code",[e._v("x (width - dataLength)")]),e._v(", where "),a("code",[e._v("dataLength")]),e._v(" is the number of elements in the current node's "),a("code",[e._v("data")]),e._v(" array and "),a("code",[e._v("height")]),e._v(" is the current node's "),a("code",[e._v("height")]),e._v(". Subtract this value from "),a("code",[e._v("size")]),e._v(" and set the result as the new "),a("code",[e._v("size")]),e._v(".")]),e._v(" "),a("li",[e._v("If the current node's "),a("code",[e._v("height")]),e._v(" is "),a("code",[e._v("0")]),e._v(".\n"),a("ol",[a("li",[e._v("Return "),a("code",[e._v("size")]),e._v(" as the correct size.")])])]),e._v(" "),a("li",[e._v("If the current node's "),a("code",[e._v("height")]),e._v(" is greater than "),a("code",[e._v("0")]),e._v(".\n"),a("ol",[a("li",[e._v("Locate the next tail node identified by the CID at the last position of the current node's "),a("code",[e._v("data")]),e._v(" array.")]),e._v(" "),a("li",[e._v('Repeat from step 2 with the next tail node as the "current node".')])])])]),e._v(" "),a("h3",{attrs:{id:"createfrom-array-width"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#createfrom-array-width"}},[e._v("#")]),e._v(" "),a("code",[e._v("CreateFrom(array, width)")])]),e._v(" "),a("ol",[a("li",[e._v("Set "),a("code",[e._v("height")]),e._v(" to "),a("code",[e._v("0")]),e._v(", indicating that each node created at this "),a("code",[e._v("height")]),e._v(" will have leaf values in it rather than links to child nodes.")]),e._v(" "),a("li",[e._v("Calculate "),a("code",[e._v("nodeCount")]),e._v(" for this "),a("code",[e._v("height")]),e._v(" with "),a("code",[e._v("ceiling(arrayLength / width)")]),e._v(", where "),a("code",[e._v("arrayLength")]),e._v(" is the number of elements in "),a("code",[e._v("array")]),e._v(".")]),e._v(" "),a("li",[e._v("Create a temporary "),a("code",[e._v("nextArray")]),e._v(" array which starts empty but will fill up to "),a("code",[e._v("nodeCount")]),e._v(".")]),e._v(" "),a("li",[e._v("Iterate with an incrementing integer "),a("code",[e._v("i")]),e._v(" from "),a("code",[e._v("0")]),e._v(" up to, but not including "),a("code",[e._v("nodeCount")]),e._v(".\n"),a("ol",[a("li",[e._v("Take a slice of "),a("code",[e._v("array")]),e._v(" beginning at element "),a("code",[e._v("i x width")]),e._v(" and ending at the element before "),a("code",[e._v("(i + 1) x width")]),e._v(" or "),a("code",[e._v("arrayLength")]),e._v(", whichever is least.")]),e._v(" "),a("li",[e._v("Create a new node, with "),a("code",[e._v("height")]),e._v(" and a "),a("code",[e._v("data")]),e._v(" array containing the array slice.")]),e._v(" "),a("li",[e._v("Append the CID for the new node to "),a("code",[e._v("nextArray")]),e._v(".")])])]),e._v(" "),a("li",[e._v("If "),a("code",[e._v("nodeCount")]),e._v(" is "),a("code",[e._v("1")]),e._v(", return the element in "),a("code",[e._v("newArray")]),e._v(" as this is the CID of the root node for the new Vector.")]),e._v(" "),a("li",[e._v("If "),a("code",[e._v("nodeCount")]),e._v(" is greater than "),a("code",[e._v("1")]),e._v(".\n"),a("ol",[a("li",[e._v("Set "),a("code",[e._v("array")]),e._v(" to be "),a("code",[e._v("newArray")]),e._v(" such that the next set of values for nodes will be links to the newly created nodes.")]),e._v(" "),a("li",[e._v("Set "),a("code",[e._v("height")]),e._v(" to "),a("code",[e._v("height + 1")]),e._v(".")]),e._v(" "),a("li",[e._v("Repeat from from step 2.")])])])]),e._v(" "),a("h3",{attrs:{id:"set-index-value"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set-index-value"}},[e._v("#")]),e._v(" "),a("code",[e._v("Set(index, value)")])]),e._v(" "),a("p",[a("em",[e._v("TODO")])]),e._v(" "),a("p",[a("em",[e._v("A combination of "),a("code",[e._v("Get")]),e._v(" for indexing, and "),a("code",[e._v("PushTail")]),e._v(" for mutation but with "),a("code",[e._v("mutate")]),e._v(" always "),a("code",[e._v("true")]),e._v(" so there are no overflows.")])]),e._v(" "),a("h3",{attrs:{id:"poptail"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#poptail"}},[e._v("#")]),e._v(" "),a("code",[e._v("PopTail()")])]),e._v(" "),a("p",[a("em",[e._v("TODO")])]),e._v(" "),a("h3",{attrs:{id:"full-copy-mutations-delete-index-pushhead-value-pophead-slice-start-end"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#full-copy-mutations-delete-index-pushhead-value-pophead-slice-start-end"}},[e._v("#")]),e._v(" Full copy mutations: "),a("code",[e._v("Delete(index)")]),e._v(", "),a("code",[e._v("PushHead(value)")]),e._v(", "),a("code",[e._v("PopHead()")]),e._v(", "),a("code",[e._v("Slice(start, end)")])]),e._v(" "),a("p",[a("em",[e._v("TODO")])]),e._v(" "),a("p",[a("em",[e._v("These will mostly involve a filtered copy with something resembling "),a("code",[e._v("CreateFrom")]),e._v(". "),a("code",[e._v("Slice")]),e._v(" may have caveats where the indexes are multiples of "),a("code",[e._v("width")]),e._v(" so may not require a full copy.")])]),e._v(" "),a("h3",{attrs:{id:"values"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#values"}},[e._v("#")]),e._v(" "),a("code",[e._v("Values()")])]),e._v(" "),a("p",[e._v("Collection-spanning iteration operations are "),a("strong",[e._v("optional")]),e._v(" for implementations, although they are encouraged as they are generally programmatically useful for ordered collections.")]),e._v(" "),a("p",[e._v("The storage order of entries in an IPLD Vector is the same as index order. Therefore, a "),a("code",[e._v("Values")]),e._v(" operation should traverse the tree from head to tail (left to right if conceptually laid out horizontally). Values should be emitted from head to tail of "),a("code",[e._v("data")]),e._v(" arrays in "),a("code",[e._v("height")]),e._v(" of "),a("code",[e._v("0")]),e._v(" nodes "),a("em",[e._v("only")]),e._v(". All other nodes with a "),a("code",[e._v("height")]),e._v(" greater than "),a("code",[e._v("0")]),e._v(" are intermediate and do not contain values so should be used for traversal only.")]),e._v(" "),a("h2",{attrs:{id:"implementation-defaults"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation-defaults"}},[e._v("#")]),e._v(" Implementation defaults")]),e._v(" "),a("p",[e._v("The only parameter that can be tuned for an IPLD Vector is the "),a("code",[e._v("width")]),e._v(". The default "),a("code",[e._v("width")]),e._v(" is "),a("code",[e._v("256")]),e._v(".")]),e._v(" "),a("p",[e._v("The intention is that IPLD data structure implementations ship with "),a("em",[e._v("sensible defaults")]),e._v(". The aim is to create Vectors without users requiring intimate knowledge of the algorithm and the all of the trade-offs (although such knowledge will help in their optimal use). The default of "),a("code",[e._v("256")]),e._v(" is descriptive rather than prescriptive. New implementations may opt for a different default for "),a("code",[e._v("width")]),e._v(", while acknowledging that they will produce different graphs (and therefore CIDs) for the same data. Users may also be provided with facilities to override these defaults to suit their use cases where these defaults do not produce optimal outcomes.")]),e._v(" "),a("p",[e._v("The primary trade-off for "),a("code",[e._v("width")]),e._v(" is node, and therefore block, size. In a maximally full node using CIDs, the block size is roughly at least "),a("code",[e._v("256 x size(CID)")]),e._v(". Users storing smaller values inline inside an IPLD Vector may opt for a large "),a("code",[e._v("width")]),e._v(" to avoid small nodes.")]),e._v(" "),a("h2",{attrs:{id:"performance-profile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#performance-profile"}},[e._v("#")]),e._v(" Performance profile")]),e._v(" "),a("ul",[a("li",[e._v("Efficient in look-up operations: "),a("code",[e._v("Get")]),e._v(" and "),a("code",[e._v("Size")]),e._v(", each requiring only a straight traversal to a "),a("code",[e._v("height")]),e._v(" of "),a("code",[e._v("0")]),e._v(" node.")]),e._v(" "),a("li",[e._v("Mutations at the tail or that change values in-place are efficient even as the data structure size increases: "),a("code",[e._v("Create")]),e._v(", "),a("code",[e._v("Replace")]),e._v(", "),a("code",[e._v("PushTail")]),e._v(" and "),a("code",[e._v("PopTail")]),e._v(". These only require mutations or the creation of nodes along the tail chain and the possible creation of a new "),a("code",[e._v("height + 1")]),e._v(" root node for full overflows.")]),e._v(" "),a("li",[e._v("Operations which mutate the size of the data structure "),a("em",[e._v("not")]),e._v(" at the tail are very inefficient: "),a("code",[e._v("PushHead")]),e._v(", "),a("code",[e._v("PopHead")]),e._v(" and any non-tail "),a("code",[e._v("Delete")]),e._v(", generally requiring copying the entire data structure.")]),e._v(" "),a("li",[a("code",[e._v("Slice")]),e._v(" / sub-tree operations are only efficient if they deal precisely with "),a("code",[e._v("width")]),e._v(" boundaries as they may not even require the creation of new nodes, simply referencing internal nodes. With large "),a("code",[e._v("width")]),e._v("s, however, we reduce the possibility of efficient slicing and must resort to copying the entire data structure.")]),e._v(" "),a("li",[e._v("Index-ordered "),a("code",[e._v("Iterator")]),e._v("s are efficient as it is a standard balanced tree traversal, left to right.")])]),e._v(" "),a("h2",{attrs:{id:"possible-future-improvements-and-areas-for-research"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#possible-future-improvements-and-areas-for-research"}},[e._v("#")]),e._v(" Possible future improvements and areas for research")]),e._v(" "),a("h3",{attrs:{id:"compression-for-sparse-arrays"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compression-for-sparse-arrays"}},[e._v("#")]),e._v(" Compression for sparse arrays")]),e._v(" "),a("p",[e._v("A compressed form of this data structure could implement a "),a("code",[e._v("map")]),e._v(" similar to the HAMT algorithm in "),a("RouterLink",{attrs:{to:"/data-structures/hashmap.html"}},[e._v("HashMap")]),e._v(" for a more classic AMT structure. This would allow variable depth node creation for sparse arrays, compressing in both depth and height. Such an implementation would store a "),a("code",[e._v("map")]),e._v(" bitmap in each node with bits set and unset to indicate whether an index is present and a "),a("code",[e._v("popcount()")]),e._v(" operation performed to find the index within the "),a("code",[e._v("data")]),e._v(" array. Where an array is very sparse, entire sections of the tree may be avoided. Algorithmic complexity is a trade-off for this implementation.")],1),e._v(" "),a("h3",{attrs:{id:"flexible-head-for-efficient-operations-a-the-head-and-for-sub-trees"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flexible-head-for-efficient-operations-a-the-head-and-for-sub-trees"}},[e._v("#")]),e._v(" Flexible head for efficient operations a the head and for sub-trees")]),e._v(" "),a("p",[e._v("By treating the head of the data structure in the same way as the tail, we could allow efficient "),a("code",[e._v("PushHead")]),e._v(" and "),a("code",[e._v("PopHead")]),e._v(" operations and efficient sub-tree or "),a("code",[e._v("Slice")]),e._v(" operations. Instead of assuming that the head chain is fixed and that the head of each "),a("code",[e._v("data")]),e._v(" array in the head chain, we allow the head chain to grow in reverse in almost the opposite way that the tail chain grows for "),a("code",[e._v("PushTail")]),e._v(" operations. "),a("code",[e._v("PushHead")]),e._v(" operations would overflow to the head of the data structure.")]),e._v(" "),a("p",[a("code",[e._v("Slice")]),e._v(" operations taking an arbitrary subset of the tree's values would only need to mutate nodes in the head chain and tail chain, leaving internal nodes intact.")]),e._v(" "),a("p",[e._v("Two primary trade-offs are an increase in algorithmic complexity and some loss of efficiency as the head chain needs to be traversed to understand both the "),a("code",[e._v("Size")]),e._v(" and the zero-reference point for "),a("code",[e._v("Get")]),e._v(" indexing. The efficiency losses could be offset by storing additional metadata in each node regarding its own head chain or its head chain size (the total number of values stored below it on nodes unaligned to "),a("code",[e._v("width")]),e._v("). By pre-loading this information we could assume both the head-leaning size for "),a("code",[e._v("Size")]),e._v(" operations and the head offset for "),a("code",[e._v("Get")]),e._v(" indexing.")]),e._v(" "),a("p",[e._v("An additional trade-off is the loss of canonical forms once any operations are performed on the head of the data structure as two trees can contain the same set of data yet yield different hashes as they are spread across differently shaped trees.")])])}),[],!1,null,null,null);t.default=r.exports}}]);