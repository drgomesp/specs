(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{286:function(e,t,a){"use strict";a.r(t);var s=a(13),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("!!!")]),e._v(" "),a("p",[e._v("This document has "),a("strong",[e._v("moved")]),e._v(".")]),e._v(" "),a("p",[e._v("You'll now find information like this in the "),a("a",{attrs:{href:"https://github.com/ipld/ipld/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ipld/ipld"),a("OutboundLink")],1),e._v(" meta-repo,\nand published to the web at https://ipld.io/ .")]),e._v(" "),a("p",[e._v("All documentation, fixtures, specifications, and web content is now gathered into that repo.\nPlease update your links, and direct new contributions there.")]),e._v(" "),a("p",[e._v("!!!")]),e._v(" "),a("hr"),e._v(" "),a("h1",{attrs:{id:"specification-dag-json"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification-dag-json"}},[e._v("#")]),e._v(" Specification: DAG-JSON")]),e._v(" "),a("p",[a("strong",[e._v("Status: Descriptive - Final")])]),e._v(" "),a("p",[e._v("DAG-JSON supports the full "),a("RouterLink",{attrs:{to:"/data-model-layer/data-model.html"}},[e._v("IPLD Data Model")]),e._v(".")],1),e._v(" "),a("p",[e._v("DAG-JSON uses the [JavaScript Object Notation (JSON)] data format, defined by "),a("a",{attrs:{href:"https://tools.ietf.org/html/rfc8259",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 8259"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"format"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#format"}},[e._v("#")]),e._v(" Format")]),e._v(" "),a("p",[e._v("The native JSON IPLD format is called DAG-JSON to disambiguate it from regular JSON. Most simple JSON objects are valid DAG-JSON. The primary differences are:")]),e._v(" "),a("ul",[a("li",[e._v("Bytes and Links are supported with special use of single-key ("),a("code",[e._v('"/"')]),e._v(") map.")]),e._v(" "),a("li",[e._v("In limited cases, maps with the key "),a("code",[e._v('"/"')]),e._v(" other than those used to encode Bytes and Links, are disallowed.")]),e._v(" "),a("li",[e._v("Maps are sorted by key.")])]),e._v(" "),a("h2",{attrs:{id:"serialization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#serialization"}},[e._v("#")]),e._v(" Serialization")]),e._v(" "),a("p",[e._v("Codec implementors "),a("strong",[e._v("MUST")]),e._v(" do the following in order to ensure hashes consistently match for the same block data.")]),e._v(" "),a("ul",[a("li",[e._v("Sort object keys by their (UTF-8) encoded representation, i.e. with byte comparisons")]),e._v(" "),a("li",[e._v("Strip whitespace")])]),e._v(" "),a("p",[e._v("This produces the most compact and consistent representation which will ensure that two codecs\nproducing the same data end up with matching block hashes.")]),e._v(" "),a("h2",{attrs:{id:"supported-kinds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#supported-kinds"}},[e._v("#")]),e._v(" Supported Kinds")]),e._v(" "),a("p",[e._v("All "),a("RouterLink",{attrs:{to:"/data-model.html#kinds"}},[e._v("IPLD Data Model Kinds")]),e._v(" except Bytes and Link are supported natively by JSON.")],1),e._v(" "),a("p",[e._v("Bytes and Links use extensions specific to DAG-JSON. They are implemented as an map, where the single key is a slash ("),a("code",[e._v('"/"')]),e._v(") and the value contains the kind's data.")]),e._v(" "),a("h3",{attrs:{id:"numbers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#numbers"}},[e._v("#")]),e._v(" Numbers")]),e._v(" "),a("p",[e._v("JSON only has a single number type. Many dynamically typed programming languages (e.g. Python, Ruby, PHP) distinguish between integers and floats when parsing JSON. JavaScript does not since all numbers are represented internally as IEEE 754 floats. A JSON number consisting of an optional leading sign ("),a("code",[e._v("-")]),e._v(") and only digits is parsed as integer, if it contains a decimal point, it's parsed as a float. DAG-JSON the same method is used to represent integers and floats.")]),e._v(" "),a("p",[e._v("Data Model floats that do not have a fractional component should be encoded "),a("strong",[e._v("with")]),e._v(" a decimal point, and will therefore be distinguishable from an integer during round-trip. (Note that since JavaScript still cannot distinguish a float from an integer where the number has no fractional component, this rule will not impact JavaScript encoding or decoding).")]),e._v(" "),a("p",[e._v("Contrary to popular belief, JSON as a format supports Big Integers. It's only JavaScript itself that has trouble with them. This means JS implementations of DAG-JSON can't use the native JSON parser and serializer if integers bigger than "),a("code",[e._v("2^53 - 1")]),e._v(" need to be supported.")]),e._v(" "),a("p",[a("code",[e._v("Infinity")]),e._v(", "),a("code",[e._v("NaN")]),e._v(" and "),a("code",[e._v("-Infinity")]),e._v(" are not natively supported by JSON and are not supported by the IPLD Data Model.")]),e._v(" "),a("p",[e._v("See further discussion on "),a("RouterLink",{attrs:{to:"/data-model.html#float-kind"}},[e._v("Floats in the Data Model")]),e._v(", including a recommendation to avoid floats where possible when producing and consuming content addressed data.")],1),e._v(" "),a("h3",{attrs:{id:"bytes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bytes"}},[e._v("#")]),e._v(" Bytes")]),e._v(" "),a("p",[e._v("The Bytes kind is represented as an object with "),a("code",[e._v('"bytes"')]),e._v(" as key and a Base64 encoded string as value. The Base64 encoding is the one described in "),a("a",{attrs:{href:"https://tools.ietf.org/html/rfc4648#section-4",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 4648, section 4"),a("OutboundLink")],1),e._v(" without padding.")]),e._v(" "),a("p",[a("em",[e._v("Note that a previous version of this specification and some implementations used a "),a("a",{attrs:{href:"https://github.com/multiformats/multibase",target:"_blank",rel:"noopener noreferrer"}},[e._v("Multibase"),a("OutboundLink")],1),e._v(" prefix "),a("code",[e._v("m")]),e._v(" for the bytes, this has been removed from the specification and the Base64 encoded bytes "),a("strong",[e._v("should not")]),e._v(" be prefixed.")])]),e._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token string-property property"}},[e._v('"/"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string-property property"}},[e._v('"bytes"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" String "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* Base64 encoded binary */")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("h3",{attrs:{id:"links"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[e._v("#")]),e._v(" Links")]),e._v(" "),a("p",[e._v("A Link kind is represented as a base encoded CID. CIDv0 and CIDv1 are encoded differently.")]),e._v(" "),a("ul",[a("li",[e._v("CIDv1 is represented as a Multibase Base32 encoded string. The Base32 encoding is the one described in "),a("a",{attrs:{href:"https://tools.ietf.org/html/rfc4648#section-6",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 4648, section 6"),a("OutboundLink")],1),e._v(" without padding, hence the Multibase prefix is "),a("code",[e._v("b")]),e._v(".")]),e._v(" "),a("li",[e._v("CIDv0 is represented in its only possible Base58 encoding. The Base58 encoding is the one described in "),a("a",{attrs:{href:"https://tools.ietf.org/html/draft-msporny-base58",target:"_blank",rel:"noopener noreferrer"}},[e._v("Base58 draft"),a("OutboundLink")],1),e._v(".")])]),e._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token string-property property"}},[e._v('"/"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" String "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* Base58 encoded CIDv0 or Multibase Base32 encoded CIDv1 */")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("h3",{attrs:{id:"the-reserved-namespace"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-reserved-namespace"}},[e._v("#")]),e._v(" The Reserved Namespace")]),e._v(" "),a("p",[e._v("Maps with the first key of "),a("code",[e._v('"/"')]),e._v(" are considered the "),a("strong",[e._v("reserved namespace")]),e._v(" in DAG-JSON as they are used to represent Bytes and Links. There are special rules that restrict certain data forms from being properly encoded in DAG-JSON. These rules allow for the clean representation of Bytes and Links as well as efficient operation of tokenizing decoders. A tokenizing decoder should not need to buffer and back-track more than 4 tokens upon detection of a map that is not properly encoding Links or Bytes.")]),e._v(" "),a("p",[e._v("The two forms used in the reserved namespace are:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("CID")]),e._v(": a map with the single key "),a("code",[e._v('"/"')]),e._v(", whose value is a string, must contain a valid CIDv0 in Base58 string form "),a("strong",[e._v("or")]),e._v(" CIDv1 in Base32 string form. Such a map whose string does not properly represent such a CID should should be rejected as invalid DAG-JSON.")]),e._v(" "),a("li",[a("strong",[e._v("Bytes")]),e._v(": A map with the single key "),a("code",[e._v('"/"')]),e._v(", whose value is a map with the single key "),a("code",[e._v('"bytes"')]),e._v(", whose value is a string, must contain a valid Base64 encoded byte array. Such a construction whose string does not properly represent a Base64 encoded byte array should be rejected as invalid DAG-JSON.")])]),e._v(" "),a("h4",{attrs:{id:"parse-rejection-modes-in-the-reserved-namespace"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parse-rejection-modes-in-the-reserved-namespace"}},[e._v("#")]),e._v(" Parse rejection modes in the reserved namespace")]),e._v(" "),a("p",[e._v("Data with the following forms are "),a("strong",[e._v("strictly not valid DAG-JSON")]),e._v(" and should be rejected by encoders and decoders:")]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Maps with more than one key, where the first key is "),a("code",[e._v('"/"')]),e._v(" and its value is a string.")])])]),e._v(" "),a("p",[e._v("e.g. "),a("code",[e._v('{"/":"foo","bar":"baz"}')])]),e._v(" "),a("ul",[a("li",[e._v("Where a key exists that sorts before "),a("code",[e._v('"/"')]),e._v(", the map is valid, e.g. "),a("code",[e._v('{"0bar":"baz","/":"foo"}')]),e._v(".")]),e._v(" "),a("li",[e._v("Where the value of the "),a("code",[e._v('"/"')]),e._v(" entry is not a string, the map is valid, e.g. "),a("code",[e._v('{"/":true,"bar":"baz"}')]),e._v(".")])]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Maps where the first key is "),a("code",[e._v('"/"')]),e._v(" and its value is a map with more than one key where the first key of the inner map is "),a("code",[e._v('"bytes"')]),e._v(" whose value is a string.")])])]),e._v(" "),a("p",[e._v("e.g. "),a("code",[e._v('{"/":{"bytes":"foo","bar":"baz"}}')])]),e._v(" "),a("ul",[a("li",[e._v("Where a key exists in the inner map that sorts before "),a("code",[e._v('"bytes"')]),e._v(", the map is valid, e.g. "),a("code",[e._v('{"/":{"abar":"baz","bytes":"foo"}}')]),e._v(".")]),e._v(" "),a("li",[e._v("Where the value of the inner map's "),a("code",[e._v('"bytes"')]),e._v(" entry is not a string, the map is valid, e.g. "),a("code",[e._v('{"/":{"bytes":true},"bar":"baz"}')]),e._v(".")])]),e._v(" "),a("p",[a("em",[a("strong",[e._v("Maps with more than one key, where the first key is "),a("code",[e._v('"/"')]),e._v(" and its value is a map where the first key of the inner map is "),a("code",[e._v('"bytes"')]),e._v(" whose value is a string.")])])]),e._v(" "),a("p",[e._v("e.g. "),a("code",[e._v('{"/":{"bytes":"foo"},"bar":"baz"}')])]),e._v(" "),a("ul",[a("li",[e._v("Where a key exists that sorts before "),a("code",[e._v('"/"')]),e._v(", the map is valid, e.g. "),a("code",[e._v('{"0bar":"baz","/":{"bytes":"foo"}}')]),e._v(".")]),e._v(" "),a("li",[e._v("Where the value of the "),a("code",[e._v('"bytes"')]),e._v(" entry in the inner map is not a string, the map is valid, e.g. "),a("code",[e._v('{"/":{"bytes":true},"bar":"baz"}')]),e._v(".")])]),e._v(" "),a("p",[e._v("There is no mechanism for escaping otherwise valid JSON data that takes these forms. For this reason, it is recommended that the "),a("code",[e._v('"/"')]),e._v(" key should be avoided in Data Model maps where DAG-JSON may be used in order to avoid such conflicts.")]),e._v(" "),a("h2",{attrs:{id:"implementations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementations"}},[e._v("#")]),e._v(" Implementations")]),e._v(" "),a("h3",{attrs:{id:"javascript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[e._v("#")]),e._v(" JavaScript")]),e._v(" "),a("p",[a("strong",[a("a",{attrs:{href:"https://github.com/ipld/js-dag-json",target:"_blank",rel:"noopener noreferrer"}},[e._v("@ipld/dag-json"),a("OutboundLink")],1)]),e._v(", for use with "),a("a",{attrs:{href:"https://github.com/multiformats/js-multiformats",target:"_blank",rel:"noopener noreferrer"}},[e._v("multiformats"),a("OutboundLink")],1),e._v(" adheres to this specification.")]),e._v(" "),a("p",[e._v("The legacy "),a("strong",[a("a",{attrs:{href:"https://github.com/ipld/js-ipld-dag-json",target:"_blank",rel:"noopener noreferrer"}},[e._v("ipld-dag-json"),a("OutboundLink")],1)]),e._v(" implementation adheres to this specification, with the following caveats:")]),e._v(" "),a("ul",[a("li",[e._v("The reserved namespace rules above are not strictly applied. Decoding maps with the forms of Bytes and Links but with additional entries in inner or outer maps will be successfuly decoded as Bytes or Links but the extraneous entries will be ignored.")]),e._v(" "),a("li",[e._v("Bytes are encoded with their Multibase Base64 prefix "),a("code",[e._v("m")]),e._v(" as per a previous version of this specification.")])]),e._v(" "),a("h3",{attrs:{id:"go"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go"}},[e._v("#")]),e._v(" Go")]),e._v(" "),a("p",[a("strong",[e._v("[go-ipld-prime]")]),e._v(" adheres to this specification with the following caveats:")]),e._v(" "),a("ul",[a("li",[e._v("Map keys are not sorted, they retain their assembled order.")]),e._v(" "),a("li",[e._v("Encoded forms are pretty-printed, i.e. do not have whitespace stripped.")])])])}),[],!1,null,null,null);t.default=r.exports}}]);