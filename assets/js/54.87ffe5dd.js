(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{322:function(t,e,s){"use strict";s.r(e);var n=s(13),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("!!!")]),t._v(" "),s("p",[t._v("This document has "),s("strong",[t._v("moved")]),t._v(".")]),t._v(" "),s("p",[t._v("You'll now find information like this in the "),s("a",{attrs:{href:"https://github.com/ipld/ipld/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ipld/ipld"),s("OutboundLink")],1),t._v(" meta-repo,\nand published to the web at https://ipld.io/ .")]),t._v(" "),s("p",[t._v("All documentation, fixtures, specifications, and web content is now gathered into that repo.\nPlease update your links, and direct new contributions there.")]),t._v(" "),s("p",[t._v("!!!")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("This document was archived from https://github.com/ipld/specs/issues/94 and was originally part of the "),s("a",{attrs:{href:"https://github.com/ipld/specs/pull/75",target:"_blank",rel:"noopener noreferrer"}},[t._v("Graphsync (b) proposal"),s("OutboundLink")],1),t._v(" by @jbenet.")]),t._v(" "),s("h2",{attrs:{id:"approach-selector-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#approach-selector-types"}},[t._v("#")]),t._v(" Approach: Selector Types")]),t._v(" "),s("p",[t._v("The requirements stated "),s("RouterLink",{attrs:{to:"/design/history/exploration-reports/2018.10-selectors-design-goals.html#selector-requirements"}},[t._v("here")]),t._v(" are hard to meet. We have spent lots of time in the last few years trying to reconcile them into one language and syntax, with no success. Earlier this year (2018) we recognized that the solution to this problem should be flexibility and interoperability: let many selector languages and syntaxes flourish, and let them evolve over time. This would allow us to satisfy all constraints, including both a permanent model that can also improve over time. And it reduces the core of our system into three components:")],1),t._v(" "),s("ul",[s("li",[t._v("(1) A system of selector types, that allows creating new selector languages and syntaxes, and can compose them.")]),t._v(" "),s("li",[t._v("(2) An easy path for plugging selector types into IPLD libraries and other consumers of IPLD Selectors.")]),t._v(" "),s("li",[t._v("(3) A light process for testing and admitting new selector types into standard IPLD libraries.")])]),t._v(" "),s("p",[t._v("These components imply or expand into the following things:")]),t._v(" "),s("ul",[s("li",[t._v("Well-defined binary and human-readable type self-description (codes in multicodec).")]),t._v(" "),s("li",[t._v("A narrow "),s("code",[t._v("Selector")]),t._v(" interface for most uses of selectors, agnostic to selector type.")]),t._v(" "),s("li",[t._v("A standard way to add selector type implementations to IPLD libraries")]),t._v(" "),s("li",[t._v("IPLD libraries that pervasively uses the abstract  "),s("code",[t._v("Selector")]),t._v(" type, and can plug in concrete types.")]),t._v(" "),s("li",[t._v("A few simple selector types that cover most common cases (cid, path, glob, ...)")]),t._v(" "),s("li",[t._v("A selector type to allow composing selectors (MultiSelector)")]),t._v(" "),s("li",[t._v("Aim for language independent implementations of selector implementations (parsers, execution, etc). (WASM?)")]),t._v(" "),s("li",[t._v("Allow language-specific implementations of selectors (parsers, execution, etc).")]),t._v(" "),s("li",[t._v("(IMPORTANT) Well-designed set of test vectors representing a variety of use cases for IPLD Selectors.")]),t._v(" "),s("li",[t._v("A recommended structure for implementing a selector type, with an easy to use test suite.")])]),t._v(" "),s("h2",{attrs:{id:"selector-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#selector-types"}},[t._v("#")]),t._v(" Selector Types")]),t._v(" "),s("p",[t._v("Selectors have multiple types")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("<selector-code> <selector-string-code> <selector-type>\n0, null, selects the empty set\n1, cid, selects a specific cid\n2, path, selects an ipld path\n3, glob, selects a unix-style glob\n4, multi, combines multiple selectors\n5, css, selects in css style\n6, git, selects with git tilde notation\n7, bitfield, selects all the nodes expressed in a bitfield\n")])])]),s("p",[s("strong",[t._v("TODO")]),t._v(": put selectors into the grand magnificent global universal multicodec table...")]),t._v(" "),s("h3",{attrs:{id:"cid-selector"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cid-selector"}},[t._v("#")]),t._v(" Cid Selector")]),t._v(" "),s("p",[t._v("This is a basic selector, that means exactly a single CID, and thus a single graph node. Nothing more.")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Binary: <selector-code><length><cid-selector-code><binary-cid>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     or: <cid-selector-code><binary-cid>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// String: /sel/cid/<multibase-encoded-cid>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" CidSelector "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Cid Cid "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// el cid")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"path-selector"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#path-selector"}},[t._v("#")]),t._v(" Path Selector")]),t._v(" "),s("p",[t._v("This is a selector w/ a path. Absolute ones must start with a CID")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Binary: <selector-code><length><path-selector-code><binary-cid><binary-path>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     or: <path-selector-code><length><binary-path>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// String: /sel/path/<multibase-encoded-cid>/a/b/c/d/...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" PathSelector "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Path Path\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"glob-selector"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#glob-selector"}},[t._v("#")]),t._v(" Glob Selector")]),t._v(" "),s("p",[t._v("This is a selector with a "),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Glob_(programming)",target:"_blank",rel:"noopener noreferrer"}},[t._v("unix shell glob"),s("OutboundLink")],1),t._v(" style thing. Absolute ones must start with a CID. It supports the following syntax:")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("*")]),t._v(" - means any number of single characters, except "),s("code",[t._v("/")]),t._v(" -- ie matches any link within a level (as in shell "),s("code",[t._v("*")]),t._v(")")]),t._v(" "),s("li",[s("code",[t._v("**")]),t._v(" - means any decendant (as in shell "),s("code",[t._v("**")]),t._v(")")]),t._v(" "),s("li",[s("code",[t._v("?")]),t._v(" - matches any single character")]),t._v(" "),s("li",[s("code",[t._v("{abc,def}")]),t._v(" - means either "),s("code",[t._v("abc")]),t._v(" or "),s("code",[t._v("def")])]),t._v(" "),s("li",[t._v("[abc] - matches one character in the bracket set.")]),t._v(" "),s("li",[t._v("[a-z] - matches one character from the (locale-dependent) range given in the bracket.")])]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Binary: <selector-code><length><glob-selector-code><binary-cid><binary-path>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     or: <glob-selector-code><length><binary-path>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// String: /sel/path/<multibase-encoded-cid>/a/*/**")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" GlobSelector "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Glob Path\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"multi-selector"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#multi-selector"}},[t._v("#")]),t._v(" Multi Selector")]),t._v(" "),s("p",[t._v("This is a selector that combines other selectors. It is a set expression.")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("union")]),t._v(" ($$ A \\cup B $$) - takes all nodes expressed by either selectors (A "),s("em",[t._v("or")]),t._v(" B)")]),t._v(" "),s("li",[s("code",[t._v("intersection")]),t._v(" ($$ A \\cap B $$) - takes all nodes expressed by both selectors (A "),s("em",[t._v("and")]),t._v(" B)")]),t._v(" "),s("li",[s("code",[t._v("difference")]),t._v(" ($$ A - B $$) - takes all nodes expressed in A, except those expressed in B (A "),s("em",[t._v("except")]),t._v(" B)")])]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Binary: <selector-code><length><multi-selector-code><sel-sexp>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//     or: <multi-selector-code><length><sel-sexp>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// String: /sel/multi/(string sel sexp)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//       no can do")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" MultiSelector "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  Op   Operator\n    Sels "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("Selector\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Operator "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  OpUnion        Operator "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    OpIntersection Operator "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n    OpDifference   Operator "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h4",{attrs:{id:"selector-s-expressions-sel-sexp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#selector-s-expressions-sel-sexp"}},[t._v("#")]),t._v(" Selector S-expressions ("),s("code",[t._v("sel-sexp")]),t._v(")")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://en.wikipedia.org/wiki/S-expression",target:"_blank",rel:"noopener noreferrer"}},[t._v("S-expressions"),s("OutboundLink")],1),t._v(" are a simple way to combine objects into nested expressions. We define this in order to have Multi Selectors. A selector s-expression ("),s("code",[t._v("sel-sexp")]),t._v(") is defined as follows.")]),t._v(" "),s("p",[t._v("Option 1 - simpler, need to nest another multiselector to nest another expression (this seems better).")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("<sel-sexp>  ::= <varint-2+><operator>(<selector>)+\n")])])]),s("p",[t._v("Option 2: more complicated at the "),s("code",[t._v("sel-sexp")]),t._v(" level, but avoids having to embed the multiselector preamble.")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("<sel-sexp>  ::= <varint-0> |\n                <varint-1><selector> |\n                <varint-2+><operator>(<sel-sexp>)+\n\n<operator>  ::= 1 (union) | 2 (intersection) | 3 (difference)\n<varint-0>  ::= 0\n<varint-1>  ::= 1\n<varint-2+> ::= 2 or more (in a varint)\n")])])]),s("h2",{attrs:{id:"ipld-interfaces-in-go-with-selectors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipld-interfaces-in-go-with-selectors"}},[t._v("#")]),t._v(" IPLD Interfaces in Go with Selectors")]),t._v(" "),s("p",[t._v("This section presents a set of possible interfaces in Go, using IPLD dags and selectors. The main purpose of this example is to show how the Selector interfaces might work in practice.")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ErrNotFound is returned when an object is not found at a particular dag.")]),t._v("\n    ErrNotFound "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" errors"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("New")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"not found"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ErrInvalidPath is returned when a path is not")]),t._v("\n    ErrInvalidPath "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" errors"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("New")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"invalid path"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// DAG is an object that provides access to an entire IPLD dag.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// It provides a handle to a set of data, all of which is rooted at one")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// node (the Root).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The interface is very simple, it only provides the Root, GetNode to retrieve")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// any sub-object by path, and Traverse, to use in algorithms that need to")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// sub-select or visit the entire dag.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This could be entirely in memory, lazy-loaded, backed by a DagService,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// or be a proxy to a remote dag.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" DAG "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Root returns the Path of the ipld node that is the root of this DAG")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// We return the Path to avoid returning an error, as returning")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the node itself may fail.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Root")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Path\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// GetNode returns an object identified by path.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Path may be absolute (start with a CID), or relative (from the root),")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// similar to how directories work in Unix filesystems.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Either way, the node returned MUST be a descendant of Root().")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// rest is the remainder if the Path, if any is left. if rest is not empty,")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// then err is not nil (ErrInvalidPath or ErrNotFound).")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The return error may be ErrNotFound, ErrInvalidPath, or errors")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// propagated from underlying systems.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("GetNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path Path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n Node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rest Path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Traverse returns a Traverser object to walk through this whole Dag.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// See the Traverser documentation for how to use it.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Traverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Traverser\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Traverser is an object that traverses a particular dag. Think of it like")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// an iterator over the whole dag. This object is in principle similar to")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// traversals like os.Walk, to iterators in c++/rust, to generators in Python,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// etc.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The implementation of a traverser is highly Dag depenedent, thus usually")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// an implementation of Dag will have a specific Traverser associated with it.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Traversers support filtering via selectors, which is an important feature.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Instead of requiring wrapping/nesting traversers (expensive), we allow")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// filtering a single traverser with multiple selectors instead (much cheaper).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This allows the logic of checking whether to consider a node to be applied")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// efficiently, ideally before the node is fetched.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TODO:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// - address skipping links, as in os.Walk. Maybe turn into a walk function.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// - return only the Path, not the node (avoid retrieving it if not needed?).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   this is similar to how os.Walk works.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Traverser "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Next returns the next node visited by this Traverser")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Next")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Node"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Filter adds a new selector to filter the nodes the Traverser will return")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Filter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sel Selector"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Selector is an object that expresses a sub-selection on a graph.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// For a more complete articulation of selectiors, read the IPLD selector")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// design document.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Note that selectors have different types, and each type will need its")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// own Go object. User code should use the selector interface and avoid")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// assuming a specific type of selector. Types are identified using a code,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// agreed upon in the multicodec table.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The selector interface in Go is a simple construct that enables reducing")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// a dag to a subset represented in a concise selector expression. All it")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// does is check whether a path is included in the selector (IncludesPath).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Using this, other objects (like the Traverser) can reduce a Dag to only")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the subdag represented by the selector.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Important note: selectors select a subdag that is also connected to the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// same dag root. Whatever nodes are selected by the selector must")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// include paths going all the way back to the root. There are no nodes")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// selected that are disconnected from the root -- at least one of their parents")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// (linked-from relationship) must also be selected.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Serialization")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// - Selectors have both string and binary representations. These are canonical")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   and can be used in a variety of places.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// - The binary representation should be used in memory, on the wire, on disk, etc.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// - The string representation should be used whenever a selector is shown to the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   user, or when the user is inputting a selector. It can also be used in other")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//   formats that aim to have high human readability (eg package.json, etc).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Selector "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// IncludesPath returns whether path p is included in this selector,")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// as applied to dag d.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// d is necessary in order to have a handle to the")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// whole dag. Selector objects themselves should be cheap and not")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// link to huge amounts of data.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("IncludesPath")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("d Dag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" p Path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bool")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// IsAbsolute returns whether the selector is absolute (rooted at a specific")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// cid in the serialized expression) or not. If it's not, it is relative,")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// which means there is no cid in the expression, and thus the selector")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// root is the root of the dag it is applied to. Intuitively, this works")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// exactly the same as shell globs in unix filesystems:")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// - Absolute: /foo/bar/baz/**/*  -> <root-cid>/bar/baz/**/*")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// - Reltaive: baz/**/*           -> baz/**/*")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("IsAbsolute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("bool")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Root returns the root Cid of this selector.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// It may be nil if the selector is not absolute.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Root")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Cid\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Type returns the selector type code.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Type")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" SelectorType\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Bytes returns the binary packed serialized representation of this selector.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Use this for all machine-oriented input/output (on the wire, disk, etc.)")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Bytes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// String returns the string serialized representation of this selector.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Use this for all human readable input/output (terminal, etc).")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// SelectorType is the enum used for selector type codes. These type codes")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// are part of the protocol and housed in the multicodec table.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" SelectorType "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    NullSelector SelectorType "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    CidSelector SelectorType "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    PathSelector SelectorType "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Select is a function that applies a selector to a dag, returning the resulting")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// subdag. It is implemented using a Traverser. Given a lazy traverser")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// implementation, it should be a lazy application and avoid visiting the whole")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// dag until it needs to.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Select")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("d Dag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" s Selector"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Dag "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    t "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Traverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Filter")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("traversedDag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// traversedDag is a utility dag implementation that uses a traverser to")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// to apply a selector. this is what Select uses.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" traversedDag "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    d Dag\n    s Selector\n    t Traverser\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("traversedDag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Root")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Node "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("IncludesPath")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("RootPath"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Root")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("nil")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("traversedDag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("GetNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path Path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Node "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("IncludesPath")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("GetNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("path"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("nil")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("traversedDag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Traverse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Traverser "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("WrapTraverser")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);